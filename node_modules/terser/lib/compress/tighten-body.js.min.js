import{AST_Array,AST_Arrow,AST_Assign,AST_Await,AST_Binary,AST_Block,AST_BlockStatement,AST_Break,AST_Call,AST_Case,AST_Chain,AST_Class,AST_Conditional,AST_Constant,AST_Continue,AST_Debugger,AST_Default,AST_Definitions,AST_DefinitionsLike,AST_Defun,AST_Destructuring,AST_Directive,AST_Dot,AST_DWLoop,AST_EmptyStatement,AST_Exit,AST_Expansion,AST_Export,AST_For,AST_ForIn,AST_If,AST_Import,AST_IterationStatement,AST_Lambda,AST_LoopControl,AST_Node,AST_Number,AST_Object,AST_ObjectKeyVal,AST_ObjectProperty,AST_PropAccess,AST_RegExp,AST_Return,AST_Scope,AST_Sequence,AST_SimpleStatement,AST_Sub,AST_Switch,AST_Symbol,AST_SymbolConst,AST_SymbolDeclaration,AST_SymbolDefun,AST_SymbolFunarg,AST_SymbolLambda,AST_SymbolLet,AST_SymbolRef,AST_SymbolUsing,AST_SymbolVar,AST_This,AST_Try,AST_TryBlock,AST_Unary,AST_UnaryPostfix,AST_UnaryPrefix,AST_Undefined,AST_Using,AST_Var,AST_VarDef,AST_With,AST_Yield,TreeTransformer,TreeWalker,walk,walk_abort,_NOINLINE}from"../ast.js";import{make_node,MAP,member,remove,has_annotation}from"../utils/index.js";import{pure_prop_access_globals}from"./native-objects.js";import{lazy_op,unary_side_effects,is_modified,is_lhs,aborts}from"./inference.js";import{WRITE_ONLY,clear_flag}from"./compressor-flags.js";import{make_sequence,merge_sequence,maintain_this_binding,is_func_expr,is_identifier_atom,is_ref_of,can_be_evicted_from_block,as_statement_array}from"./common.js";function loop_body(e){return e instanceof AST_IterationStatement&&e.body instanceof AST_BlockStatement?e.body:e}function is_lhs_read_only(e){if(e instanceof AST_This)return!0;if(e instanceof AST_SymbolRef)return e.definition().orig[0]instanceof AST_SymbolLambda;if(e instanceof AST_PropAccess){if((e=e.expression)instanceof AST_SymbolRef){if(e.is_immutable())return!1;e=e.fixed_value()}return!e||!(e instanceof AST_RegExp)&&(e instanceof AST_Constant||is_lhs_read_only(e))}return!1}function remove_initializers(e){var n=[];return e.definitions.forEach(function(e){e.name instanceof AST_SymbolDeclaration?(e.value=null,n.push(e)):e.declarations_as_names().forEach(i=>{n.push(make_node(AST_VarDef,e,{name:i,value:null}))})}),n.length?make_node(AST_Var,e,{definitions:n}):null}export function trim_unreachable_code(e,n,i){walk(n,t=>{if(t instanceof AST_Var){const e=remove_initializers(t);return e&&i.push(e),!0}return t instanceof AST_Defun&&(t===n||!e.has_directive("use strict"))?(i.push(t===n?t:make_node(AST_Var,t,{definitions:[make_node(AST_VarDef,t,{name:make_node(AST_SymbolVar,t.name,t.name),value:null})]})),!0):t instanceof AST_Export||t instanceof AST_Import?(i.push(t),!0):t instanceof AST_Scope||void 0})}export function tighten_body(e,n){const i=n.find_scope(),t=i.get_defun_scope(),{in_loop:o,in_try:a}=function(){var e=n.self(),i=0,t=!1,o=!1;do{if(e instanceof AST_IterationStatement)t=!0;else{if(e instanceof AST_Scope)break;e instanceof AST_TryBlock&&(o=!0)}}while(e=n.parent(i++));return{in_loop:t,in_try:o}}();var r,s=10;do{r=!1,c(e),n.option("dead_code")&&l(e,n),n.option("if_return")&&_(e,n),n.sequences_limit>0&&(A(e,n),u(e,n)),n.option("join_vars")&&d(e),n.option("collapse_vars")&&f(e,n)}while(r&&s-- >0);function f(e,n){if(i.pinned()||t.pinned())return e;for(var s,f=[],c=e.length,_=new TreeTransformer(function(e){if(D)return e;if(!x)return e!==S[A]?e:++A<S.length?R(e):(x=!0,(m=U(e,0))===e&&(D=!0),e);var t,o=_.parent();if(e instanceof AST_Assign&&(e.logical||"="!=e.operator&&p.equivalent_to(e.left))||e instanceof AST_Await||e instanceof AST_Using||e instanceof AST_Call&&p instanceof AST_PropAccess&&p.equivalent_to(e.expression)||(e instanceof AST_Call||e instanceof AST_PropAccess)&&e.optional||e instanceof AST_Debugger||e instanceof AST_Destructuring||e instanceof AST_Expansion&&e.expression instanceof AST_Symbol&&(e.expression instanceof AST_This||e.expression.definition().references.length>1)||e instanceof AST_IterationStatement&&!(e instanceof AST_For)||e instanceof AST_LoopControl||e instanceof AST_Try||e instanceof AST_With||e instanceof AST_Yield||e instanceof AST_Export||e instanceof AST_Class||o instanceof AST_For&&e!==o.init||!h&&e instanceof AST_SymbolRef&&!e.is_declared(n)&&!pure_prop_access_globals.has(e)||e instanceof AST_SymbolRef&&o instanceof AST_Call&&has_annotation(o,_NOINLINE)||e instanceof AST_ObjectProperty&&e.key instanceof AST_Node)return D=!0,e;if(d||b&&h||!(o instanceof AST_Binary&&lazy_op.has(o.operator)&&o.left!==e||o instanceof AST_Conditional&&o.condition!==e||o instanceof AST_If&&o.condition!==e)||(d=o),E&&!(e instanceof AST_SymbolDeclaration)&&p.equivalent_to(e)&&!function(e,n){for(const{def:i}of n.values()){const n=e.find_variable(i.name);if(n){if(n===i)continue;return!0}}return!1}(_.find_scope()||i,v)){if(d)return D=!0,e;if(is_lhs(e,o))return u&&w++,e;if(w++,u&&T instanceof AST_VarDef)return e;if(r=D=!0,T instanceof AST_UnaryPostfix)return make_node(AST_UnaryPrefix,T,T);if(T instanceof AST_VarDef){var s=T.name.definition(),f=T.value;return s.references.length-s.replaced!=1||n.exposed(s)?make_node(AST_Assign,T,{operator:"=",logical:!1,left:make_node(AST_SymbolRef,T.name,T.name),right:f}):(s.replaced++,k&&is_identifier_atom(f)?f.transform(n):maintain_this_binding(o,e,f))}return clear_flag(T,WRITE_ONLY),T}return(e instanceof AST_Call||e instanceof AST_Exit&&(y||p instanceof AST_PropAccess||z(p))||e instanceof AST_PropAccess&&(y||e.expression.may_throw_on_access(n))||e instanceof AST_SymbolRef&&(v.has(e.name)&&v.get(e.name).modified||y&&z(e))||e instanceof AST_VarDef&&e.value&&(v.has(e.name.name)||y&&z(e.name))||e instanceof AST_Using||(t=is_lhs(e.left,e))&&(t instanceof AST_PropAccess||v.has(t.name))||g&&(a?e.has_side_effects(n):M(e)))&&(m=e,e instanceof AST_Scope&&(D=!0)),R(e)},function(e){D||(m===e&&(D=!0),d===e&&(d=null))}),l=new TreeTransformer(function(e){if(D)return e;if(!x){if(e!==S[A])return e;if(++A<S.length)return;return x=!0,e}return e instanceof AST_SymbolRef&&e.name==I.name?(--w||(D=!0),is_lhs(e,l.parent())?e:(I.replaced++,u.replaced--,T.value)):e instanceof AST_Default||e instanceof AST_Scope?e:void 0});--c>=0;){0==c&&n.option("unused")&&B();var S=[];for(L(e[c]);f.length>0;){S=f.pop();var A=0,T=S[S.length-1],u=null,m=null,d=null,p=q(T);if(p&&!is_lhs_read_only(p)&&!p.has_side_effects(n)){var v=N(T),b=O(p);p instanceof AST_SymbolRef&&v.set(p.name,{def:p.definition(),modified:!1});var y=W(T),h=Y(),g=T.may_throw(n),k=T.name instanceof AST_SymbolFunarg,x=k,D=!1,w=0,E=!s||!x;if(!E){for(let e=n.self().argnames.lastIndexOf(T.name)+1;!D&&e<s.length;e++)s[e].transform(_);E=!0}for(var C=c;!D&&C<e.length;C++)e[C].transform(_);if(u){var I=T.name.definition();if(D&&I.references.length-I.replaced>w)w=!1;else{D=!1,A=0,x=k;for(C=c;!D&&C<e.length;C++)e[C].transform(l);u.single_use=!1}}w&&!F(T)&&e.splice(c,1)}}}function R(e){if(e instanceof AST_Scope)return e;if(e instanceof AST_Switch){e.expression=e.expression.transform(_);for(var n=0,i=e.body.length;!D&&n<i;n++){var t=e.body[n];if(t instanceof AST_Case){if(!x){if(t!==S[A])continue;A++}if(t.expression=t.expression.transform(_),!h)break}}return D=!0,e}}function V(e,n,i){var o=!1,a=!(e instanceof AST_Arrow);return n.walk(new TreeWalker(function(n,r){if(o)return!0;if(n instanceof AST_SymbolRef&&(e.variables.has(n.name)||function(e,n){if(e.global)return!1;let i=e.scope;for(;i&&i!==n;){if(i.variables.has(e.name))return!0;i=i.parent_scope}return!1}(n.definition(),e))){var s=n.definition().scope;if(s!==t)for(;s=s.parent_scope;)if(s===t)return!0;return o=!0}if((i||a)&&n instanceof AST_This)return o=!0;if(n instanceof AST_Scope&&!(n instanceof AST_Arrow)){var f=a;return a=!1,r(),a=f,!0}})),o}function P(e){if(e instanceof AST_Expansion)return!1;return!walk(e,e=>{if(e instanceof AST_Await)return walk_abort})}function B(){var e,i=n.self();if(is_func_expr(i)&&!i.name&&!i.uses_arguments&&!i.pinned()&&(e=n.parent())instanceof AST_Call&&e.expression===i&&e.args.every(P)){var t=n.has_directive("use strict");t&&!member(t,i.body)&&(t=!1);var o=i.argnames.length;s=e.args.slice(o);for(var a=new Set,r=o;--r>=0;){var c=i.argnames[r],_=e.args[r];const o=c.definition&&c.definition();if(!(o&&o.orig.length>1)&&(s.unshift(make_node(AST_VarDef,c,{name:c,value:_})),!a.has(c.name)))if(a.add(c.name),c instanceof AST_Expansion){var l=e.args.slice(r);l.every(e=>!V(i,e,t))&&f.unshift([make_node(AST_VarDef,c,{name:c.expression,value:make_node(AST_Array,e,{elements:l})})])}else _?(_ instanceof AST_Lambda&&_.pinned()||V(i,_,t))&&(_=null):_=make_node(AST_Undefined,c).transform(n),_&&f.unshift([make_node(AST_VarDef,c,{name:c,value:_})])}}}function L(e){if(S.push(e),e instanceof AST_Assign)e.left.has_side_effects(n)||e.right instanceof AST_Chain||f.push(S.slice()),L(e.right);else if(e instanceof AST_Binary)L(e.left),L(e.right);else if(e instanceof AST_Call&&!has_annotation(e,_NOINLINE))L(e.expression),e.args.forEach(L);else if(e instanceof AST_Case)L(e.expression);else if(e instanceof AST_Conditional)L(e.condition),L(e.consequent),L(e.alternative);else if(e instanceof AST_Definitions){var i=e.definitions.length,t=i-200;for(t<0&&(t=0);t<i;t++)L(e.definitions[t])}else e instanceof AST_DWLoop?(L(e.condition),e.body instanceof AST_Block||L(e.body)):e instanceof AST_Exit?e.value&&L(e.value):e instanceof AST_For?(e.init&&L(e.init),e.condition&&L(e.condition),e.step&&L(e.step),e.body instanceof AST_Block||L(e.body)):e instanceof AST_ForIn?(L(e.object),e.body instanceof AST_Block||L(e.body)):e instanceof AST_If?(L(e.condition),e.body instanceof AST_Block||L(e.body),!e.alternative||e.alternative instanceof AST_Block||L(e.alternative)):e instanceof AST_Sequence?e.expressions.forEach(L):e instanceof AST_SimpleStatement?L(e.body):e instanceof AST_Switch?(L(e.expression),e.body.forEach(L)):e instanceof AST_Unary?"++"!=e.operator&&"--"!=e.operator||f.push(S.slice()):e instanceof AST_VarDef&&(!e.value||e.value instanceof AST_Chain||(f.push(S.slice()),L(e.value)));S.pop()}function U(e,n,i){var t=_.parent(n);return t instanceof AST_Assign?!i||t.logical||t.left instanceof AST_PropAccess||v.has(t.left.name)?e:U(t,n+1,i):t instanceof AST_Binary?!i||lazy_op.has(t.operator)&&t.left!==e?e:U(t,n+1,i):t instanceof AST_Call||t instanceof AST_Case?e:t instanceof AST_Conditional?i&&t.condition===e?U(t,n+1,i):e:t instanceof AST_Definitions?U(t,n+1,!0):t instanceof AST_Exit?i?U(t,n+1,i):e:t instanceof AST_If?i&&t.condition===e?U(t,n+1,i):e:t instanceof AST_IterationStatement?e:t instanceof AST_Sequence?U(t,n+1,t.tail_node()!==e):t instanceof AST_SimpleStatement?U(t,n+1,!0):t instanceof AST_Switch||t instanceof AST_VarDef?e:null}function q(e){if(e instanceof AST_Assign&&e.logical)return!1;if(!(e instanceof AST_VarDef&&e.name instanceof AST_SymbolDeclaration)){const n=e instanceof AST_Assign?e.left:e.expression;return!is_ref_of(n,AST_SymbolConst)&&!is_ref_of(n,AST_SymbolLet)&&!is_ref_of(n,AST_SymbolUsing)&&n}var i=e.name.definition();if(member(e.name,i.orig)){var t=i.references.length-i.replaced;if(t)return i.orig.length-i.eliminated>1&&!(e.name instanceof AST_SymbolFunarg)||(t>1?function(e){var n=e.value;if(n instanceof AST_SymbolRef&&"arguments"!=n.name){var i=n.definition();if(!i.undeclared)return u=i}}(e):!n.exposed(i))?make_node(AST_SymbolRef,e.name,e.name):void 0}}function j(e){return e instanceof AST_Assign?e.right:e.value}function N(e){var i=new Map;if(e instanceof AST_Unary)return i;var t=new TreeWalker(function(e){for(var o=e;o instanceof AST_PropAccess;)o=o.expression;if(o instanceof AST_SymbolRef){const a=i.get(o.name);a&&a.modified||i.set(o.name,{def:o.definition(),modified:is_modified(n,t,e,e,0)})}});return j(e).walk(t),i}function F(i){if(i.name instanceof AST_SymbolFunarg){var t=n.parent(),o=n.self().argnames,a=o.indexOf(i.name);if(a<0)t.args.length=Math.min(t.args.length,o.length-1);else{var r=t.args;r[a]&&(r[a]=make_node(AST_Number,r[a],{value:0}))}return!0}var s=!1;return e[c].transform(new TreeTransformer(function(e,n,t){return s?e:e===i||e.body===i?(s=!0,e instanceof AST_VarDef?(e.value=e.name instanceof AST_SymbolConst?make_node(AST_Undefined,e.value):null,e):t?MAP.skip:null):void 0},function(e){if(e instanceof AST_Sequence)switch(e.expressions.length){case 0:return null;case 1:return e.expressions[0]}}))}function O(e){for(;e instanceof AST_PropAccess;)e=e.expression;return e instanceof AST_SymbolRef&&e.definition().scope.get_defun_scope()===t&&!(o&&(v.has(e.name)||T instanceof AST_Unary||T instanceof AST_Assign&&!T.logical&&"="!=T.operator))}function W(e){return e instanceof AST_Unary?unary_side_effects.has(e.operator):j(e).has_side_effects(n)}function Y(){if(y)return!1;if(u)return!0;if(p instanceof AST_SymbolRef){var e=p.definition();if(e.references.length-e.replaced==(T instanceof AST_VarDef?1:2))return!0}return!1}function z(e){if(!e.definition)return!0;var n=e.definition();return!(1==n.orig.length&&n.orig[0]instanceof AST_SymbolDefun)&&(n.scope.get_defun_scope()!==t||n.references.some(e=>e.scope.get_defun_scope()!==t))}function M(e,n){if(e instanceof AST_Assign)return M(e.left,!0);if(e instanceof AST_Unary)return M(e.expression,!0);if(e instanceof AST_VarDef)return e.value&&M(e.value);if(n){if(e instanceof AST_Dot)return M(e.expression,!0);if(e instanceof AST_Sub)return M(e.expression,!0);if(e instanceof AST_SymbolRef)return e.definition().scope.get_defun_scope()!==t}return!1}}function c(e){for(var n=[],i=0;i<e.length;){var t=e[i];t instanceof AST_BlockStatement&&t.body.every(can_be_evicted_from_block)?(r=!0,c(t.body),e.splice(i,1,...t.body),i+=t.body.length):t instanceof AST_EmptyStatement?(r=!0,e.splice(i,1)):t instanceof AST_Directive?n.indexOf(t.value)<0?(i++,n.push(t.value)):(r=!0,e.splice(i,1)):i++}}function _(e,n){var i=n.self(),t=function(e){for(var n=0,i=e.length;--i>=0;){var t=e[i];if(t instanceof AST_If&&t.body instanceof AST_Return&&++n>1)return!0}return!1}(e),o=i instanceof AST_Lambda;for(var a=Math.min(e.length,500);--a>=0;){var s=e[a],f=m(a),c=e[f];if(o&&!c&&s instanceof AST_Return){if(!s.value){r=!0,e.splice(a,1);continue}if(s.value instanceof AST_UnaryPrefix&&"void"==s.value.operator){r=!0,e[a]=make_node(AST_SimpleStatement,s,{body:s.value.expression});continue}}if(s instanceof AST_If){let i,t;if(i=aborts(s.body),A(i)&&(t=u(s.body,i))){i.label&&remove(i.label.thedef.references,i),r=!0,(s=s.clone()).condition=s.condition.negate(n),s.body=make_node(AST_BlockStatement,s,{body:as_statement_array(s.alternative).concat(T())}),s.alternative=make_node(AST_BlockStatement,s,{body:t}),e[a]=s.transform(n);continue}if(i=aborts(s.alternative),A(i)&&(t=u(s.alternative,i))){i.label&&remove(i.label.thedef.references,i),r=!0,(s=s.clone()).body=make_node(AST_BlockStatement,s.body,{body:as_statement_array(s.body).concat(T())}),s.alternative=make_node(AST_BlockStatement,s.alternative,{body:t}),e[a]=s.transform(n);continue}}if(s instanceof AST_If&&s.body instanceof AST_Return){var _=s.body.value;if(!_&&!s.alternative&&(o&&!c||c instanceof AST_Return&&!c.value)){r=!0,e[a]=make_node(AST_SimpleStatement,s.condition,{body:s.condition});continue}if(_&&!s.alternative&&c instanceof AST_Return&&c.value){r=!0,(s=s.clone()).alternative=c,e[a]=s.transform(n),e.splice(f,1);continue}if(_&&!s.alternative&&(!c&&o&&t||c instanceof AST_Return)){r=!0,(s=s.clone()).alternative=c||make_node(AST_Return,s,{value:null}),e[a]=s.transform(n),c&&e.splice(f,1);continue}var l=e[d(a)];if(n.option("sequences")&&o&&!s.alternative&&l instanceof AST_If&&l.body instanceof AST_Return&&m(f)==e.length&&c instanceof AST_SimpleStatement){r=!0,(s=s.clone()).alternative=make_node(AST_BlockStatement,c,{body:[c,make_node(AST_Return,c,{value:null})]}),e[a]=s.transform(n),e.splice(f,1);continue}}}function A(t){if(!t)return!1;for(var r=a+1,s=e.length;r<s;r++){var f=e[r];if(f instanceof AST_DefinitionsLike&&!(f instanceof AST_Var))return!1}var c=t instanceof AST_LoopControl?n.loopcontrol_target(t):null;return t instanceof AST_Return&&o&&function(e){return!e||e instanceof AST_UnaryPrefix&&"void"==e.operator}(t.value)||t instanceof AST_Continue&&i===loop_body(c)||t instanceof AST_Break&&c instanceof AST_BlockStatement&&i===c}function T(){var n=e.slice(a+1);return e.length=a+1,n.filter(function(n){return!(n instanceof AST_Defun)||(e.push(n),!1)})}function u(e,n){var i=as_statement_array(e);if(n===i[i.length-1]&&(i=i.slice(0,-1)).every(e=>can_be_evicted_from_block(e)))return n.value&&i.push(make_node(AST_SimpleStatement,n.value,{body:n.value.expression})),i}function m(n){for(var i=n+1,t=e.length;i<t;i++){var o=e[i];if(!(o instanceof AST_Var&&S(o)))break}return i}function d(n){for(var i=n;--i>=0;){var t=e[i];if(!(t instanceof AST_Var&&S(t)))break}return i}}function l(e,n){for(var i,t=n.self(),o=0,a=0,s=e.length;o<s;o++){var f=e[o];if(f instanceof AST_LoopControl){var c=n.loopcontrol_target(f);f instanceof AST_Break&&!(c instanceof AST_IterationStatement)&&loop_body(c)===t||f instanceof AST_Continue&&loop_body(c)===t?f.label&&remove(f.label.thedef.references,f):e[a++]=f}else e[a++]=f;if(aborts(f)){i=e.slice(o+1);break}}e.length=a,r=a!=s,i&&i.forEach(function(i){trim_unreachable_code(n,i,e)})}function S(e){return e.definitions.every(e=>!e.value)}function A(e,n){if(!(e.length<2)){for(var i=[],t=0,o=0,a=e.length;o<a;o++){var s=e[o];if(s instanceof AST_SimpleStatement){i.length>=n.sequences_limit&&c();var f=s.body;i.length>0&&(f=f.drop_side_effect_free(n)),f&&merge_sequence(i,f)}else s instanceof AST_Definitions&&S(s)||s instanceof AST_Defun||c(),e[t++]=s}c(),e.length=t,t!=a&&(r=!0)}function c(){if(i.length){var n=make_sequence(i[0],i);e[t++]=make_node(AST_SimpleStatement,n,{body:n}),i=[]}}}function T(e,n){if(!(e instanceof AST_BlockStatement))return e;for(var i=null,t=0,o=e.body.length;t<o;t++){var a=e.body[t];if(a instanceof AST_Var&&S(a))n.push(a);else{if(i||a instanceof AST_DefinitionsLike&&!(a instanceof AST_Var))return!1;i=a}}return i}function u(e,n){function i(e){o--,r=!0;var i=t.body;return make_sequence(i,[i,e]).transform(n)}for(var t,o=0,a=0;a<e.length;a++){var s=e[a];if(t)if(s instanceof AST_Exit)s.value=i(s.value||make_node(AST_Undefined,s).transform(n));else if(s instanceof AST_For){if(!(s.init instanceof AST_DefinitionsLike)){walk(t.body,e=>e instanceof AST_Scope||(e instanceof AST_Binary&&"in"===e.operator?walk_abort:void 0))||(s.init?s.init=i(s.init):(s.init=t.body,o--,r=!0))}}else s instanceof AST_ForIn?s.init instanceof AST_DefinitionsLike&&!(s.init instanceof AST_Var)||(s.object=i(s.object)):s instanceof AST_If?s.condition=i(s.condition):(s instanceof AST_Switch||s instanceof AST_With)&&(s.expression=i(s.expression));if(n.option("conditionals")&&s instanceof AST_If){var f=[],c=T(s.body,f),_=T(s.alternative,f);if(!1!==c&&!1!==_&&f.length>0){var l=f.length;f.push(make_node(AST_If,s,{condition:s.condition,body:c||make_node(AST_EmptyStatement,s.body),alternative:_})),f.unshift(o,1),[].splice.apply(e,f),a+=l,o+=l+1,t=null,r=!0;continue}}e[o++]=s,t=s instanceof AST_SimpleStatement?s:null}e.length=o}function m(e,t){if(e instanceof AST_Definitions){var o,a=e.definitions[e.definitions.length-1];if(a.value instanceof AST_Object)if(t instanceof AST_Assign&&!t.logical?o=[t]:t instanceof AST_Sequence&&(o=t.expressions.slice()),o){var r=!1;do{var s=o[0];if(!(s instanceof AST_Assign))break;if("="!=s.operator)break;if(!(s.left instanceof AST_PropAccess))break;var f=s.left.expression;if(!(f instanceof AST_SymbolRef))break;if(a.name.name!=f.name)break;if(!s.right.is_constant_expression(i))break;var c=s.left.property;if(c instanceof AST_Node&&(c=c.evaluate(n)),c instanceof AST_Node)break;c=""+c;var _=n.option("ecma")<2015&&n.has_directive("use strict")?function(e){return e.key!=c&&e.key&&e.key.name!=c}:function(e){return e.key&&e.key.name!=c};if(!a.value.properties.every(_))break;var l=a.value.properties.filter(function(e){return e.key===c})[0];l?l.value=new AST_Sequence({start:l.start,expressions:[l.value.clone(),s.right.clone()],end:l.end}):a.value.properties.push(make_node(AST_ObjectKeyVal,s,{key:c,value:s.right})),o.shift(),r=!0}while(o.length);return r&&o}}}function d(e){for(var n,i=0,t=-1,o=e.length;i<o;i++){var a=e[i],s=e[t];if(a instanceof AST_Definitions)s&&s.TYPE==a.TYPE?(s.definitions=s.definitions.concat(a.definitions),r=!0):n&&n.TYPE==a.TYPE&&S(a)?(n.definitions=n.definitions.concat(a.definitions),r=!0):(e[++t]=a,n=a);else if(a instanceof AST_Using&&s instanceof AST_Using&&s.await===a.await)s.definitions=s.definitions.concat(a.definitions);else if(a instanceof AST_Exit)a.value=c(a.value);else if(a instanceof AST_For){(f=m(s,a.init))?(r=!0,a.init=f.length?make_sequence(a.init,f):null,e[++t]=a):s instanceof AST_Var&&(!a.init||a.init.TYPE==s.TYPE)?(a.init&&(s.definitions=s.definitions.concat(a.init.definitions)),a.init=s,e[t]=a,r=!0):n instanceof AST_Var&&a.init instanceof AST_Var&&S(a.init)?(n.definitions=n.definitions.concat(a.init.definitions),a.init=null,e[++t]=a,r=!0):e[++t]=a}else if(a instanceof AST_ForIn)a.object=c(a.object);else if(a instanceof AST_If)a.condition=c(a.condition);else if(a instanceof AST_SimpleStatement){var f;if(f=m(s,a.body)){if(r=!0,!f.length)continue;a.body=make_sequence(a.body,f)}e[++t]=a}else a instanceof AST_Switch||a instanceof AST_With?a.expression=c(a.expression):e[++t]=a}function c(n){e[++t]=a;var i=m(s,n);return i?(r=!0,i.length?make_sequence(n,i):n instanceof AST_Sequence?n.tail_node().left:n.left):n}e.length=t+1}}