import{AST_Array,AST_Arrow,AST_BigInt,AST_BlockStatement,AST_Call,AST_Chain,AST_Class,AST_Const,AST_Constant,AST_DefClass,AST_Defun,AST_EmptyStatement,AST_Export,AST_False,AST_Function,AST_Import,AST_Infinity,AST_LabeledStatement,AST_Lambda,AST_Let,AST_LoopControl,AST_NaN,AST_Node,AST_Null,AST_Number,AST_Object,AST_ObjectKeyVal,AST_PropAccess,AST_RegExp,AST_Scope,AST_Sequence,AST_SimpleStatement,AST_Statement,AST_String,AST_SymbolRef,AST_True,AST_UnaryPrefix,AST_Undefined,AST_Using,TreeWalker,walk,walk_abort,walk_parent}from"../ast.js";import{make_node,regexp_source_fix,string_template,makePredicate}from"../utils/index.js";import{first_in_statement}from"../utils/first_in_statement.js";import{has_flag,TOP}from"./compressor-flags.js";export function merge_sequence(e,n){return n instanceof AST_Sequence?e.push(...n.expressions):e.push(n),e}export function make_sequence(e,n){if(1==n.length)return n[0];if(0==n.length)throw new Error("trying to create a sequence with length zero!");return make_node(AST_Sequence,e,{expressions:n.reduce(merge_sequence,[])})}export function make_empty_function(e){return make_node(AST_Function,e,{uses_arguments:!1,argnames:[],body:[],is_generator:!1,async:!1,variables:new Map,uses_with:!1,uses_eval:!1,parent_scope:null,enclosed:[],cname:0,block_scope:void 0})}export function make_node_from_constant(e,n){switch(typeof e){case"string":return make_node(AST_String,n,{value:e});case"number":return isNaN(e)?make_node(AST_NaN,n):isFinite(e)?1/e<0?make_node(AST_UnaryPrefix,n,{operator:"-",expression:make_node(AST_Number,n,{value:-e})}):make_node(AST_Number,n,{value:e}):e<0?make_node(AST_UnaryPrefix,n,{operator:"-",expression:make_node(AST_Infinity,n)}):make_node(AST_Infinity,n);case"bigint":return make_node(AST_BigInt,n,{value:e.toString()});case"boolean":return make_node(e?AST_True:AST_False,n);case"undefined":return make_node(AST_Undefined,n);default:if(null===e)return make_node(AST_Null,n,{value:null});if(e instanceof RegExp)return make_node(AST_RegExp,n,{value:{source:regexp_source_fix(e.source),flags:e.flags}});throw new Error(string_template("Can't handle constant of type: {type}",{type:typeof e}))}}export function best_of_expression(e,n){return e.size()>n.size()?n:e}export function best_of_statement(e,n){return best_of_expression(make_node(AST_SimpleStatement,e,{body:e}),make_node(AST_SimpleStatement,n,{body:n})).body}export function best_of(e,n,t){return first_in_statement(e)?best_of_statement(n,t):best_of_expression(n,t)}export function get_simple_key(e){return e instanceof AST_Constant?e.getValue():e instanceof AST_UnaryPrefix&&"void"==e.operator&&e.expression instanceof AST_Constant?void 0:e}export function read_property(e,n){if(!((n=get_simple_key(n))instanceof AST_Node)){var t;if(e instanceof AST_Array){var r=e.elements;if("length"==n)return make_node_from_constant(r.length,e);"number"==typeof n&&n in r&&(t=r[n])}else if(e instanceof AST_Object){n=""+n;for(var o=e.properties,i=o.length;--i>=0;){if(!(o[i]instanceof AST_ObjectKeyVal))return;t||o[i].key!==n||(t=o[i].value)}}return t instanceof AST_SymbolRef&&t.fixed_value()||t}}export function has_break_or_continue(e,n){var t=!1,r=new TreeWalker(function(n){return!!(t||n instanceof AST_Scope)||(n instanceof AST_LoopControl&&r.loopcontrol_target(n)===e?t=!0:void 0)});return n instanceof AST_LabeledStatement&&r.push(n),r.push(e),e.body.walk(r),t}export function maintain_this_binding(e,n,t){if(requires_sequence_to_maintain_binding(e,n,t)){return make_sequence(n,[make_node(AST_Number,n,{value:0}),t])}return t}export function requires_sequence_to_maintain_binding(e,n,t){return e instanceof AST_UnaryPrefix&&"delete"==e.operator||e instanceof AST_Call&&e.expression===n&&(t instanceof AST_Chain||t instanceof AST_PropAccess||t instanceof AST_SymbolRef&&"eval"==t.name)}export function is_func_expr(e){return e instanceof AST_Arrow||e instanceof AST_Function}export function is_iife_call(e){return"Call"==e.TYPE&&(e.expression instanceof AST_Function||is_iife_call(e.expression))}export function is_empty(e){return null===e||(e instanceof AST_EmptyStatement||e instanceof AST_BlockStatement&&0==e.body.length)}export const identifier_atom=makePredicate("Infinity NaN undefined");export function is_identifier_atom(e){return e instanceof AST_Infinity||e instanceof AST_NaN||e instanceof AST_Undefined}export function is_ref_of(e,n){if(!(e instanceof AST_SymbolRef))return!1;for(var t=e.definition().orig,r=t.length;--r>=0;)if(t[r]instanceof n)return!0}export function can_be_evicted_from_block(e){return!(e instanceof AST_DefClass||e instanceof AST_Defun||e instanceof AST_Let||e instanceof AST_Const||e instanceof AST_Using||e instanceof AST_Export||e instanceof AST_Import)}export function as_statement_array(e){if(null===e)return[];if(e instanceof AST_BlockStatement)return e.body;if(e instanceof AST_EmptyStatement)return[];if(e instanceof AST_Statement)return[e];throw new Error("Can't convert thing to statement array")}export function is_reachable(e,n){const t=e=>{if(e instanceof AST_SymbolRef&&n.includes(e.definition()))return walk_abort};return walk_parent(e,(n,r)=>{if(n instanceof AST_Scope&&n!==e){var o=r.parent();if(o instanceof AST_Call&&o.expression===n&&!n.async&&!n.is_generator)return;return!walk(n,t)||walk_abort}})}export function is_recursive_ref(e,n){for(var t,r=0;t=e.parent(r);r++)if(t instanceof AST_Lambda||t instanceof AST_Class){var o=t.name;if(o&&o.definition()===n)return!0}return!1}export function retain_top_func(e,n){return n.top_retain&&e instanceof AST_Defun&&has_flag(e,TOP)&&e.name&&n.top_retain(e.name.definition())}