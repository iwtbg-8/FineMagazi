import{AST_Accessor,AST_Assign,AST_BlockStatement,AST_Call,AST_Class,AST_ClassExpression,AST_ClassStaticBlock,AST_DefaultAssign,AST_DefClass,AST_Definitions,AST_Defun,AST_Destructuring,AST_EmptyStatement,AST_Expansion,AST_Export,AST_For,AST_ForIn,AST_Function,AST_LabeledStatement,AST_Lambda,AST_Number,AST_Scope,AST_Sequence,AST_SimpleStatement,AST_SymbolBlockDeclaration,AST_SymbolCatch,AST_SymbolDeclaration,AST_SymbolFunarg,AST_SymbolRef,AST_SymbolVar,AST_Toplevel,AST_Unary,AST_Var,TreeTransformer,TreeWalker,walk}from"../ast.js";import{keep_name,make_node,map_add,MAP,remove,return_false}from"../utils/index.js";import{SymbolDef}from"../scope.js";import{WRITE_ONLY,UNUSED,has_flag,set_flag}from"./compressor-flags.js";import{make_sequence,maintain_this_binding,is_empty,is_ref_of,can_be_evicted_from_block}from"./common.js";import{is_used_in_expression}from"./inference.js";const r_keep_assign=/keep_assign/;AST_Scope.DEFMETHOD("drop_unused",function(e){if(!e.option("unused"))return;if(e.has_directive("use asm"))return;if(!this.variables)return;var n=this;if(n.pinned())return;var i=!(n instanceof AST_Toplevel)||e.toplevel.funcs,a=!(n instanceof AST_Toplevel)||e.toplevel.vars;const t=r_keep_assign.test(e.option("unused"))?return_false:function(e){return e instanceof AST_Assign&&!e.logical&&(has_flag(e,WRITE_ONLY)||"="==e.operator)?e.left:e instanceof AST_Unary&&has_flag(e,WRITE_ONLY)?e.expression:void 0};var s=new Map,o=new Map;n instanceof AST_Toplevel&&e.top_retain&&n.variables.forEach(function(n){e.top_retain(n)&&s.set(n.id,n)});var r=new Map,f=new Map,_=this,l=new TreeWalker(function(t,c){if(t instanceof AST_Lambda&&t.uses_arguments&&!l.has_directive("use strict")&&t.argnames.forEach(function(e){if(e instanceof AST_SymbolDeclaration){var n=e.definition();s.set(n.id,n)}}),t===n)return;if(t instanceof AST_Class&&t.has_side_effects(e)&&(t.is_self_referential()?c():t.visit_nondeferred_class_parts(l)),t instanceof AST_Defun||t instanceof AST_DefClass){var m=t.name.definition();return(l.parent()instanceof AST_Export||!i&&_===n)&&m.global&&s.set(m.id,m),map_add(f,m.id,t),!0}const u=_===n;if(t instanceof AST_SymbolFunarg&&u&&map_add(r,t.definition().id,t),t instanceof AST_Definitions&&u){const n=l.parent()instanceof AST_Export;return t.definitions.forEach(function(i){if(i.name instanceof AST_SymbolVar&&map_add(r,i.name.definition().id,i),!n&&a||walk(i.name,e=>{if(e instanceof AST_SymbolDeclaration){const n=e.definition();n.global&&s.set(n.id,n)}}),i.name instanceof AST_Destructuring&&i.walk(l),i.name instanceof AST_SymbolDeclaration&&i.value){var t=i.name.definition();map_add(f,t.id,i.value),t.chained||i.name.fixed_value()!==i.value||o.set(t.id,i),i.value.has_side_effects(e)&&i.value.walk(l)}}),!0}return S(t,c)});n.walk(l),l=new TreeWalker(S),s.forEach(function(e){var n=f.get(e.id);n&&n.forEach(function(e){e.walk(l)})});var c=new TreeTransformer(function(f,l,S){var m=c.parent();if(a){const n=t(f);if(n instanceof AST_SymbolRef){var u=n.definition(),d=s.has(u.id);if(f instanceof AST_Assign){if(!d||o.has(u.id)&&o.get(u.id)!==f){const n=f.right.transform(c);return d||n.has_side_effects(e)||is_used_in_expression(c)?maintain_this_binding(m,f,n):S?MAP.skip:make_node(AST_Number,f,{value:0})}}else if(!d)return S?MAP.skip:make_node(AST_Number,f,{value:0})}}if(_===n){if(f.name&&(f instanceof AST_ClassExpression&&!keep_name(e.option("keep_classnames"),(u=f.name.definition()).name)||f instanceof AST_Function&&!keep_name(e.option("keep_fnames"),(u=f.name.definition()).name))&&(!s.has(u.id)||u.orig.length>1)&&(f.name=null),f instanceof AST_Lambda&&!(f instanceof AST_Accessor))for(var A=!e.option("keep_fargs")||m instanceof AST_Call&&m.expression===f&&!f.pinned()&&(!f.name||f.name.unreferenced()),p=f.argnames,T=p.length;--T>=0;){var v=p[T];v instanceof AST_Expansion&&(v=v.expression),v instanceof AST_DefaultAssign&&(v=v.left),v instanceof AST_Destructuring||s.has(v.definition().id)?A=!1:(set_flag(v,UNUSED),A&&p.pop())}if(f instanceof AST_DefClass&&f!==n){const n=f.name.definition();l(f,this);if(!(n.global&&!i||s.has(n.id))){const i=f.drop_side_effect_free(e);return null==i?(n.eliminated++,S?MAP.skip:make_node(AST_EmptyStatement,f)):i}return f}if(f instanceof AST_Defun&&f!==n){const e=f.name.definition();if(!(e.global&&!i||s.has(e.id)))return e.eliminated++,S?MAP.skip:make_node(AST_EmptyStatement,f)}if(f instanceof AST_Definitions&&!(m instanceof AST_ForIn&&m.init===f)){var h=!(m instanceof AST_Toplevel||f instanceof AST_Var),g=[],b=[],k=[],y=[];switch(f.definitions.forEach(function(n){n.value&&(n.value=n.value.transform(c));var i=n.name instanceof AST_Destructuring,t=i?new SymbolDef(null,{name:"<destructure>"}):n.name.definition();if(h&&t.global)return k.push(n);if(!a&&!h||i&&(n.name.names.length||n.name.is_array||1!=e.option("pure_getters"))||s.has(t.id)){if(n.value&&o.has(t.id)&&o.get(t.id)!==n&&(n.value=n.value.drop_side_effect_free(e)),n.name instanceof AST_SymbolVar){var _=r.get(t.id);if(_.length>1&&(!n.value||t.orig.indexOf(n.name)>t.eliminated)){if(n.value){var l=make_node(AST_SymbolRef,n.name,n.name);t.references.push(l);var S=make_node(AST_Assign,n,{operator:"=",logical:!1,left:l,right:n.value});o.get(t.id)===n&&o.set(t.id,S),y.push(S.transform(c))}return remove(_,n),void t.eliminated++}}n.value?(y.length>0&&(k.length>0?(y.push(n.value),n.value=make_sequence(n.value,y)):g.push(make_node(AST_SimpleStatement,f,{body:make_sequence(f,y)})),y=[]),k.push(n)):b.push(n)}else if(t.orig[0]instanceof AST_SymbolCatch){(m=n.value&&n.value.drop_side_effect_free(e))&&y.push(m),n.value=null,b.push(n)}else{var m;(m=n.value&&n.value.drop_side_effect_free(e))&&y.push(m),t.eliminated++}}),(b.length>0||k.length>0)&&(f.definitions=b.concat(k),g.push(f)),y.length>0&&g.push(make_node(AST_SimpleStatement,f,{body:make_sequence(f,y)})),g.length){case 0:return S?MAP.skip:make_node(AST_EmptyStatement,f);case 1:return g[0];default:return S?MAP.splice(g):make_node(AST_BlockStatement,f,{body:g})}}if(f instanceof AST_For)return l(f,this),f.init instanceof AST_BlockStatement&&(D=f.init,f.init=D.body.pop(),D.body.push(f)),f.init instanceof AST_SimpleStatement?f.init=f.init.body:is_empty(f.init)&&(f.init=null),D?S?MAP.splice(D.body):D:f;if(f instanceof AST_LabeledStatement&&f.body instanceof AST_For){if(l(f,this),f.body instanceof AST_BlockStatement){var D=f.body;return f.body=D.body.pop(),D.body.push(f),S?MAP.splice(D.body):D}return f}if(f instanceof AST_BlockStatement)return l(f,this),S&&f.body.every(can_be_evicted_from_block)?MAP.splice(f.body):f;if(f instanceof AST_Scope&&!(f instanceof AST_ClassStaticBlock)){const e=_;return _=f,l(f,this),_=e,f}}},function(e,n){if(e instanceof AST_Sequence)switch(e.expressions.length){case 0:return n?MAP.skip:make_node(AST_Number,e,{value:0});case 1:return e.expressions[0]}});function S(e,i){var a;const r=t(e);if(r instanceof AST_SymbolRef&&!is_ref_of(e.left,AST_SymbolBlockDeclaration)&&n.variables.get(r.name)===(a=r.definition()))return e instanceof AST_Assign&&(e.right.walk(l),a.chained||e.left.fixed_value()!==e.right||o.set(a.id,e)),!0;if(e instanceof AST_SymbolRef){if(a=e.definition(),!s.has(a.id)&&(s.set(a.id,a),a.orig[0]instanceof AST_SymbolCatch)){const e=a.scope.is_block_scope()&&a.scope.get_defun_scope().variables.get(a.name);e&&s.set(e.id,e)}return!0}if(e instanceof AST_Class)return i(),!0;if(e instanceof AST_Scope&&!(e instanceof AST_ClassStaticBlock)){var f=_;return _=e,i(),_=f,!0}}n.transform(c)});