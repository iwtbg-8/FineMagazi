import{HOP,MAP,noop}from"./utils/index.js";import{parse}from"./parse.js";function DEFNODE(t,e,s,i,n=AST_Node){var o=e=e?e.split(/\s+/):[];n&&n.PROPS&&(e=e.concat(n.PROPS));const a=n&&Object.create(n.prototype);if(a&&(s.prototype=a,s.BASE=n),n&&n.SUBCLASSES.push(s),s.prototype.CTOR=s,s.prototype.constructor=s,s.PROPS=e||null,s.SELF_PROPS=o,s.SUBCLASSES=[],t&&(s.prototype.TYPE=s.TYPE=t),i)for(let t in i)HOP(i,t)&&("$"===t[0]?s[t.substr(1)]=i[t]:s.prototype[t]=i[t]);return s.DEFMETHOD=function(t,e){this.prototype[t]=e},s}const has_tok_flag=(t,e)=>Boolean(t.flags&e),set_tok_flag=(t,e,s)=>{s?t.flags|=e:t.flags&=~e},TOK_FLAG_NLB=1,TOK_FLAG_QUOTE_SINGLE=2,TOK_FLAG_QUOTE_EXISTS=4,TOK_FLAG_TEMPLATE_END=8;class AST_Token{constructor(t,e,s,i,n,o,a,r,l){this.flags=o?1:0,this.type=t,this.value=e,this.line=s,this.col=i,this.pos=n,this.comments_before=a,this.comments_after=r,this.file=l,Object.seal(this)}[Symbol.for("nodejs.util.inspect.custom")](t,e){const s=t=>e.stylize(t,"special"),i="string"==typeof this.value&&this.value.includes("`")?"'":"`",n=`${i}${this.value}${i}`;return`${s("[AST_Token")} ${n} at ${this.line}:${this.col}${s("]")}`}get nlb(){return has_tok_flag(this,1)}set nlb(t){set_tok_flag(this,1,t)}get quote(){return has_tok_flag(this,4)?has_tok_flag(this,2)?"'":'"':""}set quote(t){set_tok_flag(this,2,"'"===t),set_tok_flag(this,4,!!t)}get template_end(){return has_tok_flag(this,8)}set template_end(t){set_tok_flag(this,8,t)}}var AST_Node=DEFNODE("Node","start end",function(t){t&&(this.start=t.start,this.end=t.end),this.flags=0},{_clone:function(t){if(t){var e=this.clone();return e.transform(new TreeTransformer(function(t){if(t!==e)return t.clone(!0)}))}return new this.CTOR(this)},clone:function(t){return this._clone(t)},$documentation:"Base class of all AST nodes",$propdoc:{start:"[AST_Token] The first token of this node",end:"[AST_Token] The last token of this node"},_walk:function(t){return t._visit(this)},walk:function(t){return this._walk(t)},_children_backwards:()=>{}},null),AST_Statement=DEFNODE("Statement",null,function(t){t&&(this.start=t.start,this.end=t.end),this.flags=0},{$documentation:"Base class of all statements"}),AST_Debugger=DEFNODE("Debugger",null,function(t){t&&(this.start=t.start,this.end=t.end),this.flags=0},{$documentation:"Represents a debugger statement"},AST_Statement),AST_Directive=DEFNODE("Directive","value quote",function(t){t&&(this.value=t.value,this.quote=t.quote,this.start=t.start,this.end=t.end),this.flags=0},{$documentation:'Represents a directive, like "use strict";',$propdoc:{value:"[string] The value of this directive as a plain string (it's not an AST_String!)",quote:"[string] the original quote character"}},AST_Statement),AST_SimpleStatement=DEFNODE("SimpleStatement","body",function(t){t&&(this.body=t.body,this.start=t.start,this.end=t.end),this.flags=0},{$documentation:"A statement consisting of an expression, i.e. a = 1 + 2",$propdoc:{body:"[AST_Node] an expression node (should not be instanceof AST_Statement)"},_walk:function(t){return t._visit(this,function(){this.body._walk(t)})},_children_backwards(t){t(this.body)}},AST_Statement);function walk_body(t,e){const s=t.body;for(var i=0,n=s.length;i<n;i++)s[i]._walk(e)}function clone_block_scope(t){var e=this._clone(t);return this.block_scope&&(e.block_scope=this.block_scope.clone()),e}var AST_Block=DEFNODE("Block","body block_scope",function(t){t&&(this.body=t.body,this.block_scope=t.block_scope,this.start=t.start,this.end=t.end),this.flags=0},{$documentation:"A body of statements (usually braced)",$propdoc:{body:"[AST_Statement*] an array of statements",block_scope:"[AST_Scope] the block scope"},_walk:function(t){return t._visit(this,function(){walk_body(this,t)})},_children_backwards(t){let e=this.body.length;for(;e--;)t(this.body[e])},clone:clone_block_scope},AST_Statement),AST_BlockStatement=DEFNODE("BlockStatement",null,function(t){t&&(this.body=t.body,this.block_scope=t.block_scope,this.start=t.start,this.end=t.end),this.flags=0},{$documentation:"A block statement"},AST_Block),AST_EmptyStatement=DEFNODE("EmptyStatement",null,function(t){t&&(this.start=t.start,this.end=t.end),this.flags=0},{$documentation:"The empty statement (empty block or simply a semicolon)"},AST_Statement),AST_StatementWithBody=DEFNODE("StatementWithBody","body",function(t){t&&(this.body=t.body,this.start=t.start,this.end=t.end),this.flags=0},{$documentation:"Base class for all statements that contain one nested body: `For`, `ForIn`, `Do`, `While`, `With`",$propdoc:{body:"[AST_Statement] the body; this should always be present, even if it's an AST_EmptyStatement"}},AST_Statement),AST_LabeledStatement=DEFNODE("LabeledStatement","label",function(t){t&&(this.label=t.label,this.body=t.body,this.start=t.start,this.end=t.end),this.flags=0},{$documentation:"Statement with a label",$propdoc:{label:"[AST_Label] a label definition"},_walk:function(t){return t._visit(this,function(){this.label._walk(t),this.body._walk(t)})},_children_backwards(t){t(this.body),t(this.label)},clone:function(t){var e=this._clone(t);if(t){var s=e.label,i=this.label;e.walk(new TreeWalker(function(t){t instanceof AST_LoopControl&&t.label&&t.label.thedef===i&&(t.label.thedef=s,s.references.push(t))}))}return e}},AST_StatementWithBody),AST_IterationStatement=DEFNODE("IterationStatement","block_scope",function(t){t&&(this.block_scope=t.block_scope,this.body=t.body,this.start=t.start,this.end=t.end),this.flags=0},{$documentation:"Internal class.  All loops inherit from it.",$propdoc:{block_scope:"[AST_Scope] the block scope for this iteration statement."},clone:clone_block_scope},AST_StatementWithBody),AST_DWLoop=DEFNODE("DWLoop","condition",function(t){t&&(this.condition=t.condition,this.block_scope=t.block_scope,this.body=t.body,this.start=t.start,this.end=t.end),this.flags=0},{$documentation:"Base class for do/while statements",$propdoc:{condition:"[AST_Node] the loop condition.  Should not be instanceof AST_Statement"}},AST_IterationStatement),AST_Do=DEFNODE("Do",null,function(t){t&&(this.condition=t.condition,this.block_scope=t.block_scope,this.body=t.body,this.start=t.start,this.end=t.end),this.flags=0},{$documentation:"A `do` statement",_walk:function(t){return t._visit(this,function(){this.body._walk(t),this.condition._walk(t)})},_children_backwards(t){t(this.condition),t(this.body)}},AST_DWLoop),AST_While=DEFNODE("While",null,function(t){t&&(this.condition=t.condition,this.block_scope=t.block_scope,this.body=t.body,this.start=t.start,this.end=t.end),this.flags=0},{$documentation:"A `while` statement",_walk:function(t){return t._visit(this,function(){this.condition._walk(t),this.body._walk(t)})},_children_backwards(t){t(this.body),t(this.condition)}},AST_DWLoop),AST_For=DEFNODE("For","init condition step",function(t){t&&(this.init=t.init,this.condition=t.condition,this.step=t.step,this.block_scope=t.block_scope,this.body=t.body,this.start=t.start,this.end=t.end),this.flags=0},{$documentation:"A `for` statement",$propdoc:{init:"[AST_Node?] the `for` initialization code, or null if empty",condition:"[AST_Node?] the `for` termination clause, or null if empty",step:"[AST_Node?] the `for` update clause, or null if empty"},_walk:function(t){return t._visit(this,function(){this.init&&this.init._walk(t),this.condition&&this.condition._walk(t),this.step&&this.step._walk(t),this.body._walk(t)})},_children_backwards(t){t(this.body),this.step&&t(this.step),this.condition&&t(this.condition),this.init&&t(this.init)}},AST_IterationStatement),AST_ForIn=DEFNODE("ForIn","init object",function(t){t&&(this.init=t.init,this.object=t.object,this.block_scope=t.block_scope,this.body=t.body,this.start=t.start,this.end=t.end),this.flags=0},{$documentation:"A `for ... in` statement",$propdoc:{init:"[AST_Node] the `for/in` initialization code",object:"[AST_Node] the object that we're looping through"},_walk:function(t){return t._visit(this,function(){this.init._walk(t),this.object._walk(t),this.body._walk(t)})},_children_backwards(t){t(this.body),this.object&&t(this.object),this.init&&t(this.init)}},AST_IterationStatement),AST_ForOf=DEFNODE("ForOf","await",function(t){t&&(this.await=t.await,this.init=t.init,this.object=t.object,this.block_scope=t.block_scope,this.body=t.body,this.start=t.start,this.end=t.end),this.flags=0},{$documentation:"A `for ... of` statement"},AST_ForIn),AST_With=DEFNODE("With","expression",function(t){t&&(this.expression=t.expression,this.body=t.body,this.start=t.start,this.end=t.end),this.flags=0},{$documentation:"A `with` statement",$propdoc:{expression:"[AST_Node] the `with` expression"},_walk:function(t){return t._visit(this,function(){this.expression._walk(t),this.body._walk(t)})},_children_backwards(t){t(this.body),t(this.expression)}},AST_StatementWithBody),AST_Scope=DEFNODE("Scope","variables uses_with uses_eval parent_scope enclosed cname",function(t){t&&(this.variables=t.variables,this.uses_with=t.uses_with,this.uses_eval=t.uses_eval,this.parent_scope=t.parent_scope,this.enclosed=t.enclosed,this.cname=t.cname,this.body=t.body,this.block_scope=t.block_scope,this.start=t.start,this.end=t.end),this.flags=0},{$documentation:"Base class for all statements introducing a lexical scope",$propdoc:{variables:"[Map/S] a map of name -> SymbolDef for all variables/functions defined in this scope",uses_with:"[boolean/S] tells whether this scope uses the `with` statement",uses_eval:"[boolean/S] tells whether this scope contains a direct call to the global `eval`",parent_scope:"[AST_Scope?/S] link to the parent scope",enclosed:"[SymbolDef*/S] a list of all symbol definitions that are accessed from this scope or any subscopes",cname:"[integer/S] current index for mangling variables (used internally by the mangler)"},get_defun_scope:function(){for(var t=this;t.is_block_scope();)t=t.parent_scope;return t},clone:function(t,e){var s=this._clone(t);return t&&this.variables&&e&&!this._block_scope?s.figure_out_scope({},{toplevel:e,parent_scope:this.parent_scope}):(this.variables&&(s.variables=new Map(this.variables)),this.enclosed&&(s.enclosed=this.enclosed.slice()),this._block_scope&&(s._block_scope=this._block_scope)),s},pinned:function(){return this.uses_eval||this.uses_with}},AST_Block),AST_Toplevel=DEFNODE("Toplevel","globals",function(t){t&&(this.globals=t.globals,this.variables=t.variables,this.uses_with=t.uses_with,this.uses_eval=t.uses_eval,this.parent_scope=t.parent_scope,this.enclosed=t.enclosed,this.cname=t.cname,this.body=t.body,this.block_scope=t.block_scope,this.start=t.start,this.end=t.end),this.flags=0},{$documentation:"The toplevel scope",$propdoc:{globals:"[Map/S] a map of name -> SymbolDef for all undeclared names"},wrap_commonjs:function(t){var e=this.body,s="(function(exports){'$ORIG';})(typeof "+t+"=='undefined'?("+t+"={}):"+t+");";return s=(s=parse(s)).transform(new TreeTransformer(function(t){if(t instanceof AST_Directive&&"$ORIG"==t.value)return MAP.splice(e)}))},wrap_enclose:function(t){"string"!=typeof t&&(t="");var e=t.indexOf(":");e<0&&(e=t.length);var s=this.body;return parse(["(function(",t.slice(0,e),'){"$ORIG"})(',t.slice(e+1),")"].join("")).transform(new TreeTransformer(function(t){if(t instanceof AST_Directive&&"$ORIG"==t.value)return MAP.splice(s)}))}},AST_Scope),AST_Expansion=DEFNODE("Expansion","expression",function(t){t&&(this.expression=t.expression,this.start=t.start,this.end=t.end),this.flags=0},{$documentation:"An expandible argument, such as ...rest, a splat, such as [1,2,...all], or an expansion in a variable declaration, such as var [first, ...rest] = list",$propdoc:{expression:"[AST_Node] the thing to be expanded"},_walk:function(t){return t._visit(this,function(){this.expression.walk(t)})},_children_backwards(t){t(this.expression)}}),AST_Lambda=DEFNODE("Lambda","name argnames uses_arguments is_generator async",function(t){t&&(this.name=t.name,this.argnames=t.argnames,this.uses_arguments=t.uses_arguments,this.is_generator=t.is_generator,this.async=t.async,this.variables=t.variables,this.uses_with=t.uses_with,this.uses_eval=t.uses_eval,this.parent_scope=t.parent_scope,this.enclosed=t.enclosed,this.cname=t.cname,this.body=t.body,this.block_scope=t.block_scope,this.start=t.start,this.end=t.end),this.flags=0},{$documentation:"Base class for functions",$propdoc:{name:"[AST_SymbolDeclaration?] the name of this function",argnames:"[AST_SymbolFunarg|AST_Destructuring|AST_Expansion|AST_DefaultAssign*] array of function arguments, destructurings, or expanding arguments",uses_arguments:"[boolean/S] tells whether this function accesses the arguments array",is_generator:"[boolean] is this a generator method",async:"[boolean] is this method async"},args_as_names:function(){for(var t=[],e=0;e<this.argnames.length;e++)this.argnames[e]instanceof AST_Destructuring?t.push(...this.argnames[e].all_symbols()):t.push(this.argnames[e]);return t},_walk:function(t){return t._visit(this,function(){this.name&&this.name._walk(t);for(var e=this.argnames,s=0,i=e.length;s<i;s++)e[s]._walk(t);walk_body(this,t)})},_children_backwards(t){let e=this.body.length;for(;e--;)t(this.body[e]);for(e=this.argnames.length;e--;)t(this.argnames[e]);this.name&&t(this.name)},is_braceless(){return this.body[0]instanceof AST_Return&&this.body[0].value},length_property(){let t=0;for(const e of this.argnames)(e instanceof AST_SymbolFunarg||e instanceof AST_Destructuring)&&t++;return t}},AST_Scope),AST_Accessor=DEFNODE("Accessor",null,function(t){t&&(this.name=t.name,this.argnames=t.argnames,this.uses_arguments=t.uses_arguments,this.is_generator=t.is_generator,this.async=t.async,this.variables=t.variables,this.uses_with=t.uses_with,this.uses_eval=t.uses_eval,this.parent_scope=t.parent_scope,this.enclosed=t.enclosed,this.cname=t.cname,this.body=t.body,this.block_scope=t.block_scope,this.start=t.start,this.end=t.end),this.flags=0},{$documentation:"A setter/getter function.  The `name` property is always null."},AST_Lambda),AST_Function=DEFNODE("Function",null,function(t){t&&(this.name=t.name,this.argnames=t.argnames,this.uses_arguments=t.uses_arguments,this.is_generator=t.is_generator,this.async=t.async,this.variables=t.variables,this.uses_with=t.uses_with,this.uses_eval=t.uses_eval,this.parent_scope=t.parent_scope,this.enclosed=t.enclosed,this.cname=t.cname,this.body=t.body,this.block_scope=t.block_scope,this.start=t.start,this.end=t.end),this.flags=0},{$documentation:"A function expression"},AST_Lambda),AST_Arrow=DEFNODE("Arrow",null,function(t){t&&(this.name=t.name,this.argnames=t.argnames,this.uses_arguments=t.uses_arguments,this.is_generator=t.is_generator,this.async=t.async,this.variables=t.variables,this.uses_with=t.uses_with,this.uses_eval=t.uses_eval,this.parent_scope=t.parent_scope,this.enclosed=t.enclosed,this.cname=t.cname,this.body=t.body,this.block_scope=t.block_scope,this.start=t.start,this.end=t.end),this.flags=0},{$documentation:"An ES6 Arrow function ((a) => b)"},AST_Lambda),AST_Defun=DEFNODE("Defun",null,function(t){t&&(this.name=t.name,this.argnames=t.argnames,this.uses_arguments=t.uses_arguments,this.is_generator=t.is_generator,this.async=t.async,this.variables=t.variables,this.uses_with=t.uses_with,this.uses_eval=t.uses_eval,this.parent_scope=t.parent_scope,this.enclosed=t.enclosed,this.cname=t.cname,this.body=t.body,this.block_scope=t.block_scope,this.start=t.start,this.end=t.end),this.flags=0},{$documentation:"A function definition"},AST_Lambda),AST_Destructuring=DEFNODE("Destructuring","names is_array",function(t){t&&(this.names=t.names,this.is_array=t.is_array,this.start=t.start,this.end=t.end),this.flags=0},{$documentation:"A destructuring of several names. Used in destructuring assignment and with destructuring function argument names",$propdoc:{names:"[AST_Node*] Array of properties or elements",is_array:"[Boolean] Whether the destructuring represents an object or array"},_walk:function(t){return t._visit(this,function(){this.names.forEach(function(e){e._walk(t)})})},_children_backwards(t){let e=this.names.length;for(;e--;)t(this.names[e])},all_symbols:function(){var t=[];return walk(this,e=>{if(e instanceof AST_SymbolDeclaration&&t.push(e),e instanceof AST_Lambda)return!0}),t}}),AST_PrefixedTemplateString=DEFNODE("PrefixedTemplateString","template_string prefix",function(t){t&&(this.template_string=t.template_string,this.prefix=t.prefix,this.start=t.start,this.end=t.end),this.flags=0},{$documentation:"A templatestring with a prefix, such as String.raw`foobarbaz`",$propdoc:{template_string:"[AST_TemplateString] The template string",prefix:"[AST_Node] The prefix, which will get called."},_walk:function(t){return t._visit(this,function(){this.prefix._walk(t),this.template_string._walk(t)})},_children_backwards(t){t(this.template_string),t(this.prefix)}}),AST_TemplateString=DEFNODE("TemplateString","segments",function(t){t&&(this.segments=t.segments,this.start=t.start,this.end=t.end),this.flags=0},{$documentation:"A template string literal",$propdoc:{segments:"[AST_Node*] One or more segments, starting with AST_TemplateSegment. AST_Node may follow AST_TemplateSegment, but each AST_Node must be followed by AST_TemplateSegment."},_walk:function(t){return t._visit(this,function(){this.segments.forEach(function(e){e._walk(t)})})},_children_backwards(t){let e=this.segments.length;for(;e--;)t(this.segments[e])}}),AST_TemplateSegment=DEFNODE("TemplateSegment","value raw",function(t){t&&(this.value=t.value,this.raw=t.raw,this.start=t.start,this.end=t.end),this.flags=0},{$documentation:"A segment of a template string literal",$propdoc:{value:"Content of the segment",raw:"Raw source of the segment"}}),AST_Jump=DEFNODE("Jump",null,function(t){t&&(this.start=t.start,this.end=t.end),this.flags=0},{$documentation:"Base class for “jumps” (for now that's `return`, `throw`, `break` and `continue`)"},AST_Statement),AST_Exit=DEFNODE("Exit","value",function(t){t&&(this.value=t.value,this.start=t.start,this.end=t.end),this.flags=0},{$documentation:"Base class for “exits” (`return` and `throw`)",$propdoc:{value:"[AST_Node?] the value returned or thrown by this statement; could be null for AST_Return"},_walk:function(t){return t._visit(this,this.value&&function(){this.value._walk(t)})},_children_backwards(t){this.value&&t(this.value)}},AST_Jump),AST_Return=DEFNODE("Return",null,function(t){t&&(this.value=t.value,this.start=t.start,this.end=t.end),this.flags=0},{$documentation:"A `return` statement"},AST_Exit),AST_Throw=DEFNODE("Throw",null,function(t){t&&(this.value=t.value,this.start=t.start,this.end=t.end),this.flags=0},{$documentation:"A `throw` statement"},AST_Exit),AST_LoopControl=DEFNODE("LoopControl","label",function(t){t&&(this.label=t.label,this.start=t.start,this.end=t.end),this.flags=0},{$documentation:"Base class for loop control statements (`break` and `continue`)",$propdoc:{label:"[AST_LabelRef?] the label, or null if none"},_walk:function(t){return t._visit(this,this.label&&function(){this.label._walk(t)})},_children_backwards(t){this.label&&t(this.label)}},AST_Jump),AST_Break=DEFNODE("Break",null,function(t){t&&(this.label=t.label,this.start=t.start,this.end=t.end),this.flags=0},{$documentation:"A `break` statement"},AST_LoopControl),AST_Continue=DEFNODE("Continue",null,function(t){t&&(this.label=t.label,this.start=t.start,this.end=t.end),this.flags=0},{$documentation:"A `continue` statement"},AST_LoopControl),AST_Await=DEFNODE("Await","expression",function(t){t&&(this.expression=t.expression,this.start=t.start,this.end=t.end),this.flags=0},{$documentation:"An `await` statement",$propdoc:{expression:"[AST_Node] the mandatory expression being awaited"},_walk:function(t){return t._visit(this,function(){this.expression._walk(t)})},_children_backwards(t){t(this.expression)}}),AST_Yield=DEFNODE("Yield","expression is_star",function(t){t&&(this.expression=t.expression,this.is_star=t.is_star,this.start=t.start,this.end=t.end),this.flags=0},{$documentation:"A `yield` statement",$propdoc:{expression:"[AST_Node?] the value returned or thrown by this statement; could be null (representing undefined) but only when is_star is set to false",is_star:"[Boolean] Whether this is a yield or yield* statement"},_walk:function(t){return t._visit(this,this.expression&&function(){this.expression._walk(t)})},_children_backwards(t){this.expression&&t(this.expression)}}),AST_If=DEFNODE("If","condition alternative",function(t){t&&(this.condition=t.condition,this.alternative=t.alternative,this.body=t.body,this.start=t.start,this.end=t.end),this.flags=0},{$documentation:"A `if` statement",$propdoc:{condition:"[AST_Node] the `if` condition",alternative:"[AST_Statement?] the `else` part, or null if not present"},_walk:function(t){return t._visit(this,function(){this.condition._walk(t),this.body._walk(t),this.alternative&&this.alternative._walk(t)})},_children_backwards(t){this.alternative&&t(this.alternative),t(this.body),t(this.condition)}},AST_StatementWithBody),AST_Switch=DEFNODE("Switch","expression",function(t){t&&(this.expression=t.expression,this.body=t.body,this.block_scope=t.block_scope,this.start=t.start,this.end=t.end),this.flags=0},{$documentation:"A `switch` statement",$propdoc:{expression:"[AST_Node] the `switch` “discriminant”"},_walk:function(t){return t._visit(this,function(){this.expression._walk(t),walk_body(this,t)})},_children_backwards(t){let e=this.body.length;for(;e--;)t(this.body[e]);t(this.expression)}},AST_Block),AST_SwitchBranch=DEFNODE("SwitchBranch",null,function(t){t&&(this.body=t.body,this.block_scope=t.block_scope,this.start=t.start,this.end=t.end),this.flags=0},{$documentation:"Base class for `switch` branches"},AST_Block),AST_Default=DEFNODE("Default",null,function(t){t&&(this.body=t.body,this.block_scope=t.block_scope,this.start=t.start,this.end=t.end),this.flags=0},{$documentation:"A `default` switch branch"},AST_SwitchBranch),AST_Case=DEFNODE("Case","expression",function(t){t&&(this.expression=t.expression,this.body=t.body,this.block_scope=t.block_scope,this.start=t.start,this.end=t.end),this.flags=0},{$documentation:"A `case` switch branch",$propdoc:{expression:"[AST_Node] the `case` expression"},_walk:function(t){return t._visit(this,function(){this.expression._walk(t),walk_body(this,t)})},_children_backwards(t){let e=this.body.length;for(;e--;)t(this.body[e]);t(this.expression)}},AST_SwitchBranch),AST_Try=DEFNODE("Try","body bcatch bfinally",function(t){t&&(this.body=t.body,this.bcatch=t.bcatch,this.bfinally=t.bfinally,this.start=t.start,this.end=t.end),this.flags=0},{$documentation:"A `try` statement",$propdoc:{body:"[AST_TryBlock] the try block",bcatch:"[AST_Catch?] the catch block, or null if not present",bfinally:"[AST_Finally?] the finally block, or null if not present"},_walk:function(t){return t._visit(this,function(){this.body._walk(t),this.bcatch&&this.bcatch._walk(t),this.bfinally&&this.bfinally._walk(t)})},_children_backwards(t){this.bfinally&&t(this.bfinally),this.bcatch&&t(this.bcatch),t(this.body)}},AST_Statement),AST_TryBlock=DEFNODE("TryBlock",null,function(t){t&&(this.body=t.body,this.block_scope=t.block_scope,this.start=t.start,this.end=t.end),this.flags=0},{$documentation:"The `try` block of a try statement"},AST_Block),AST_Catch=DEFNODE("Catch","argname",function(t){t&&(this.argname=t.argname,this.body=t.body,this.block_scope=t.block_scope,this.start=t.start,this.end=t.end),this.flags=0},{$documentation:"A `catch` node; only makes sense as part of a `try` statement",$propdoc:{argname:"[AST_SymbolCatch|AST_Destructuring|AST_Expansion|AST_DefaultAssign] symbol for the exception"},_walk:function(t){return t._visit(this,function(){this.argname&&this.argname._walk(t),walk_body(this,t)})},_children_backwards(t){let e=this.body.length;for(;e--;)t(this.body[e]);this.argname&&t(this.argname)}},AST_Block),AST_Finally=DEFNODE("Finally",null,function(t){t&&(this.body=t.body,this.block_scope=t.block_scope,this.start=t.start,this.end=t.end),this.flags=0},{$documentation:"A `finally` node; only makes sense as part of a `try` statement"},AST_Block),AST_DefinitionsLike=DEFNODE("DefinitionsLike","definitions",function(t){t&&(this.definitions=t.definitions,this.start=t.start,this.end=t.end),this.flags=0},{$documentation:"Base class for variable definitions and `using`",$propdoc:{definitions:"[AST_VarDef*|AST_UsingDef*] array of variable definitions"},_walk:function(t){return t._visit(this,function(){for(var e=this.definitions,s=0,i=e.length;s<i;s++)e[s]._walk(t)})},_children_backwards(t){let e=this.definitions.length;for(;e--;)t(this.definitions[e])}},AST_Statement),AST_Definitions=DEFNODE("Definitions",null,function(t){t&&(this.definitions=t.definitions,this.start=t.start,this.end=t.end),this.flags=0},{$documentation:"Base class for `var` or `const` nodes (variable declarations/initializations)"},AST_DefinitionsLike),AST_Var=DEFNODE("Var",null,function(t){t&&(this.definitions=t.definitions,this.start=t.start,this.end=t.end),this.flags=0},{$documentation:"A `var` statement"},AST_Definitions),AST_Let=DEFNODE("Let",null,function(t){t&&(this.definitions=t.definitions,this.start=t.start,this.end=t.end),this.flags=0},{$documentation:"A `let` statement"},AST_Definitions),AST_Const=DEFNODE("Const",null,function(t){t&&(this.definitions=t.definitions,this.start=t.start,this.end=t.end),this.flags=0},{$documentation:"A `const` statement"},AST_Definitions),AST_Using=DEFNODE("Using","await",function(t){t&&(this.await=t.await,this.definitions=t.definitions,this.start=t.start,this.end=t.end),this.flags=0},{$documentation:"A `using` statement",$propdoc:{await:"[boolean] Whether it's `await using`"}},AST_DefinitionsLike),AST_VarDefLike=DEFNODE("VarDefLike","name value",function(t){t&&(this.name=t.name,this.value=t.value,this.start=t.start,this.end=t.end),this.flags=0},{$documentation:"A name=value pair in a variable definition statement or `using`",$propdoc:{name:"[AST_Destructuring|AST_SymbolDeclaration] name of the variable",value:"[AST_Node?] initializer, or null of there's no initializer"},_walk:function(t){return t._visit(this,function(){this.name._walk(t),this.value&&this.value._walk(t)})},_children_backwards(t){this.value&&t(this.value),t(this.name)},declarations_as_names(){return this.name instanceof AST_SymbolDeclaration?[this.name]:this.name.all_symbols()}}),AST_VarDef=DEFNODE("VarDef",null,function(t){t&&(this.name=t.name,this.value=t.value,this.start=t.start,this.end=t.end),this.flags=0},{$documentation:"A variable declaration; only appears in a AST_Definitions node"},AST_VarDefLike),AST_UsingDef=DEFNODE("UsingDef",null,function(t){t&&(this.name=t.name,this.value=t.value,this.start=t.start,this.end=t.end),this.flags=0},{$documentation:"Like VarDef but specific to AST_Using"},AST_VarDefLike),AST_NameMapping=DEFNODE("NameMapping","foreign_name name",function(t){t&&(this.foreign_name=t.foreign_name,this.name=t.name,this.start=t.start,this.end=t.end),this.flags=0},{$documentation:"The part of the export/import statement that declare names from a module.",$propdoc:{foreign_name:"[AST_SymbolExportForeign|AST_SymbolImportForeign] The name being exported/imported (as specified in the module)",name:"[AST_SymbolExport|AST_SymbolImport] The name as it is visible to this module."},_walk:function(t){return t._visit(this,function(){this.foreign_name._walk(t),this.name._walk(t)})},_children_backwards(t){t(this.name),t(this.foreign_name)}}),AST_Import=DEFNODE("Import","imported_name imported_names module_name attributes",function(t){t&&(this.imported_name=t.imported_name,this.imported_names=t.imported_names,this.module_name=t.module_name,this.attributes=t.attributes,this.start=t.start,this.end=t.end),this.flags=0},{$documentation:"An `import` statement",$propdoc:{imported_name:"[AST_SymbolImport] The name of the variable holding the module's default export.",imported_names:"[AST_NameMapping*] The names of non-default imported variables",module_name:"[AST_String] String literal describing where this module came from",attributes:"[AST_Object?] The import attributes (with {...})"},_walk:function(t){return t._visit(this,function(){this.imported_name&&this.imported_name._walk(t),this.imported_names&&this.imported_names.forEach(function(e){e._walk(t)}),this.module_name._walk(t)})},_children_backwards(t){if(t(this.module_name),this.imported_names){let e=this.imported_names.length;for(;e--;)t(this.imported_names[e])}this.imported_name&&t(this.imported_name)}}),AST_ImportMeta=DEFNODE("ImportMeta",null,function(t){t&&(this.start=t.start,this.end=t.end),this.flags=0},{$documentation:"A reference to import.meta"}),AST_Export=DEFNODE("Export","exported_definition exported_value is_default exported_names module_name attributes",function(t){t&&(this.exported_definition=t.exported_definition,this.exported_value=t.exported_value,this.is_default=t.is_default,this.exported_names=t.exported_names,this.module_name=t.module_name,this.attributes=t.attributes,this.start=t.start,this.end=t.end),this.flags=0},{$documentation:"An `export` statement",$propdoc:{exported_definition:"[AST_Defun|AST_Definitions|AST_DefClass?] An exported definition",exported_value:"[AST_Node?] An exported value",exported_names:"[AST_NameMapping*?] List of exported names",module_name:"[AST_String?] Name of the file to load exports from",is_default:"[Boolean] Whether this is the default exported value of this module",attributes:"[AST_Object?] The import attributes"},_walk:function(t){return t._visit(this,function(){this.exported_definition&&this.exported_definition._walk(t),this.exported_value&&this.exported_value._walk(t),this.exported_names&&this.exported_names.forEach(function(e){e._walk(t)}),this.module_name&&this.module_name._walk(t)})},_children_backwards(t){if(this.module_name&&t(this.module_name),this.exported_names){let e=this.exported_names.length;for(;e--;)t(this.exported_names[e])}this.exported_value&&t(this.exported_value),this.exported_definition&&t(this.exported_definition)}},AST_Statement),AST_Call=DEFNODE("Call","expression args optional _annotations",function(t){t&&(this.expression=t.expression,this.args=t.args,this.optional=t.optional,this._annotations=t._annotations,this.start=t.start,this.end=t.end,this.initialize()),this.flags=0},{$documentation:"A function call expression",$propdoc:{expression:"[AST_Node] expression to invoke as function",args:"[AST_Node*] array of arguments",optional:"[boolean] whether this is an optional call (IE ?.() )",_annotations:"[number] bitfield containing information about the call"},initialize(){null==this._annotations&&(this._annotations=0)},_walk(t){return t._visit(this,function(){for(var e=this.args,s=0,i=e.length;s<i;s++)e[s]._walk(t);this.expression._walk(t)})},_children_backwards(t){let e=this.args.length;for(;e--;)t(this.args[e]);t(this.expression)}}),AST_New=DEFNODE("New",null,function(t){t&&(this.expression=t.expression,this.args=t.args,this.optional=t.optional,this._annotations=t._annotations,this.start=t.start,this.end=t.end,this.initialize()),this.flags=0},{$documentation:"An object instantiation.  Derives from a function call since it has exactly the same properties"},AST_Call),AST_Sequence=DEFNODE("Sequence","expressions",function(t){t&&(this.expressions=t.expressions,this.start=t.start,this.end=t.end),this.flags=0},{$documentation:"A sequence expression (comma-separated expressions)",$propdoc:{expressions:"[AST_Node*] array of expressions (at least two)"},_walk:function(t){return t._visit(this,function(){this.expressions.forEach(function(e){e._walk(t)})})},_children_backwards(t){let e=this.expressions.length;for(;e--;)t(this.expressions[e])}}),AST_PropAccess=DEFNODE("PropAccess","expression property optional",function(t){t&&(this.expression=t.expression,this.property=t.property,this.optional=t.optional,this.start=t.start,this.end=t.end),this.flags=0},{$documentation:'Base class for property access expressions, i.e. `a.foo` or `a["foo"]`',$propdoc:{expression:"[AST_Node] the “container” expression",property:"[AST_Node|string] the property to access.  For AST_Dot & AST_DotHash this is always a plain string, while for AST_Sub it's an arbitrary AST_Node",optional:"[boolean] whether this is an optional property access (IE ?.)"}}),AST_Dot=DEFNODE("Dot","quote",function(t){t&&(this.quote=t.quote,this.expression=t.expression,this.property=t.property,this.optional=t.optional,this._annotations=t._annotations,this.start=t.start,this.end=t.end),this.flags=0},{$documentation:"A dotted property access expression",$propdoc:{quote:"[string] the original quote character when transformed from AST_Sub"},_walk:function(t){return t._visit(this,function(){this.expression._walk(t)})},_children_backwards(t){t(this.expression)}},AST_PropAccess),AST_DotHash=DEFNODE("DotHash","",function(t){t&&(this.expression=t.expression,this.property=t.property,this.optional=t.optional,this.start=t.start,this.end=t.end),this.flags=0},{$documentation:"A dotted property access to a private property",_walk:function(t){return t._visit(this,function(){this.expression._walk(t)})},_children_backwards(t){t(this.expression)}},AST_PropAccess),AST_Sub=DEFNODE("Sub",null,function(t){t&&(this.expression=t.expression,this.property=t.property,this.optional=t.optional,this._annotations=t._annotations,this.start=t.start,this.end=t.end),this.flags=0},{$documentation:'Index-style property access, i.e. `a["foo"]`',_walk:function(t){return t._visit(this,function(){this.expression._walk(t),this.property._walk(t)})},_children_backwards(t){t(this.property),t(this.expression)}},AST_PropAccess),AST_Chain=DEFNODE("Chain","expression",function(t){t&&(this.expression=t.expression,this.start=t.start,this.end=t.end),this.flags=0},{$documentation:"A chain expression like a?.b?.(c)?.[d]",$propdoc:{expression:"[AST_Call|AST_Dot|AST_DotHash|AST_Sub] chain element."},_walk:function(t){return t._visit(this,function(){this.expression._walk(t)})},_children_backwards(t){t(this.expression)}}),AST_Unary=DEFNODE("Unary","operator expression",function(t){t&&(this.operator=t.operator,this.expression=t.expression,this.start=t.start,this.end=t.end),this.flags=0},{$documentation:"Base class for unary expressions",$propdoc:{operator:"[string] the operator",expression:"[AST_Node] expression that this unary operator applies to"},_walk:function(t){return t._visit(this,function(){this.expression._walk(t)})},_children_backwards(t){t(this.expression)}}),AST_UnaryPrefix=DEFNODE("UnaryPrefix",null,function(t){t&&(this.operator=t.operator,this.expression=t.expression,this.start=t.start,this.end=t.end),this.flags=0},{$documentation:"Unary prefix expression, i.e. `typeof i` or `++i`"},AST_Unary),AST_UnaryPostfix=DEFNODE("UnaryPostfix",null,function(t){t&&(this.operator=t.operator,this.expression=t.expression,this.start=t.start,this.end=t.end),this.flags=0},{$documentation:"Unary postfix expression, i.e. `i++`"},AST_Unary),AST_Binary=DEFNODE("Binary","operator left right",function(t){t&&(this.operator=t.operator,this.left=t.left,this.right=t.right,this.start=t.start,this.end=t.end),this.flags=0},{$documentation:"Binary expression, i.e. `a + b`",$propdoc:{left:"[AST_Node] left-hand side expression",operator:"[string] the operator",right:"[AST_Node] right-hand side expression"},_walk:function(t){return t._visit(this,function(){this.left._walk(t),this.right._walk(t)})},_children_backwards(t){t(this.right),t(this.left)}}),AST_Conditional=DEFNODE("Conditional","condition consequent alternative",function(t){t&&(this.condition=t.condition,this.consequent=t.consequent,this.alternative=t.alternative,this.start=t.start,this.end=t.end),this.flags=0},{$documentation:"Conditional expression using the ternary operator, i.e. `a ? b : c`",$propdoc:{condition:"[AST_Node]",consequent:"[AST_Node]",alternative:"[AST_Node]"},_walk:function(t){return t._visit(this,function(){this.condition._walk(t),this.consequent._walk(t),this.alternative._walk(t)})},_children_backwards(t){t(this.alternative),t(this.consequent),t(this.condition)}}),AST_Assign=DEFNODE("Assign","logical",function(t){t&&(this.logical=t.logical,this.operator=t.operator,this.left=t.left,this.right=t.right,this.start=t.start,this.end=t.end),this.flags=0},{$documentation:"An assignment expression — `a = b + 5`",$propdoc:{logical:"Whether it's a logical assignment"}},AST_Binary),AST_DefaultAssign=DEFNODE("DefaultAssign",null,function(t){t&&(this.operator=t.operator,this.left=t.left,this.right=t.right,this.start=t.start,this.end=t.end),this.flags=0},{$documentation:"A default assignment expression like in `(a = 3) => a`"},AST_Binary),AST_Array=DEFNODE("Array","elements",function(t){t&&(this.elements=t.elements,this.start=t.start,this.end=t.end),this.flags=0},{$documentation:"An array literal",$propdoc:{elements:"[AST_Node*] array of elements"},_walk:function(t){return t._visit(this,function(){for(var e=this.elements,s=0,i=e.length;s<i;s++)e[s]._walk(t)})},_children_backwards(t){let e=this.elements.length;for(;e--;)t(this.elements[e])}}),AST_Object=DEFNODE("Object","properties",function(t){t&&(this.properties=t.properties,this.start=t.start,this.end=t.end),this.flags=0},{$documentation:"An object literal",$propdoc:{properties:"[AST_ObjectProperty*] array of properties"},_walk:function(t){return t._visit(this,function(){for(var e=this.properties,s=0,i=e.length;s<i;s++)e[s]._walk(t)})},_children_backwards(t){let e=this.properties.length;for(;e--;)t(this.properties[e])}}),AST_ObjectProperty=DEFNODE("ObjectProperty","key value",function(t){t&&(this.key=t.key,this.value=t.value,this.start=t.start,this.end=t.end,this._annotations=t._annotations),this.flags=0},{$documentation:"Base class for literal object properties",$propdoc:{key:"[string|AST_Node] property name. For ObjectKeyVal this is a string. For getters, setters and computed property this is an AST_Node.",value:"[AST_Node] property value.  For getters, setters and methods this is an AST_Accessor."},_walk:function(t){return t._visit(this,function(){this.key instanceof AST_Node&&this.key._walk(t),this.value._walk(t)})},_children_backwards(t){t(this.value),this.key instanceof AST_Node&&t(this.key)}}),AST_ObjectKeyVal=DEFNODE("ObjectKeyVal","quote",function(t){t&&(this.quote=t.quote,this.key=t.key,this.value=t.value,this.start=t.start,this.end=t.end,this._annotations=t._annotations),this.flags=0},{$documentation:"A key: value object property",$propdoc:{quote:"[string] the original quote character"},computed_key(){return this.key instanceof AST_Node}},AST_ObjectProperty),AST_PrivateSetter=DEFNODE("PrivateSetter","static",function(t){t&&(this.static=t.static,this.key=t.key,this.value=t.value,this.start=t.start,this.end=t.end),this.flags=0},{$propdoc:{static:"[boolean] whether this is a static private setter"},$documentation:"A private setter property",computed_key:()=>!1},AST_ObjectProperty),AST_PrivateGetter=DEFNODE("PrivateGetter","static",function(t){t&&(this.static=t.static,this.key=t.key,this.value=t.value,this.start=t.start,this.end=t.end),this.flags=0},{$propdoc:{static:"[boolean] whether this is a static private getter"},$documentation:"A private getter property",computed_key:()=>!1},AST_ObjectProperty),AST_ObjectSetter=DEFNODE("ObjectSetter","quote static",function(t){t&&(this.quote=t.quote,this.static=t.static,this.key=t.key,this.value=t.value,this.start=t.start,this.end=t.end,this._annotations=t._annotations),this.flags=0},{$propdoc:{quote:"[string|undefined] the original quote character, if any",static:"[boolean] whether this is a static setter (classes only)"},$documentation:"An object setter property",computed_key(){return!(this.key instanceof AST_SymbolMethod)}},AST_ObjectProperty),AST_ObjectGetter=DEFNODE("ObjectGetter","quote static",function(t){t&&(this.quote=t.quote,this.static=t.static,this.key=t.key,this.value=t.value,this.start=t.start,this.end=t.end,this._annotations=t._annotations),this.flags=0},{$propdoc:{quote:"[string|undefined] the original quote character, if any",static:"[boolean] whether this is a static getter (classes only)"},$documentation:"An object getter property",computed_key(){return!(this.key instanceof AST_SymbolMethod)}},AST_ObjectProperty),AST_ConciseMethod=DEFNODE("ConciseMethod","quote static",function(t){t&&(this.quote=t.quote,this.static=t.static,this.key=t.key,this.value=t.value,this.start=t.start,this.end=t.end,this._annotations=t._annotations),this.flags=0},{$propdoc:{quote:"[string|undefined] the original quote character, if any",static:"[boolean] is this method static (classes only)"},$documentation:"An ES6 concise method inside an object or class",computed_key(){return!(this.key instanceof AST_SymbolMethod)}},AST_ObjectProperty),AST_PrivateMethod=DEFNODE("PrivateMethod","static",function(t){t&&(this.static=t.static,this.key=t.key,this.value=t.value,this.start=t.start,this.end=t.end),this.flags=0},{$documentation:"A private class method inside a class",$propdoc:{static:"[boolean] is this a static private method"},computed_key:()=>!1},AST_ObjectProperty),AST_Class=DEFNODE("Class","name extends properties",function(t){t&&(this.name=t.name,this.extends=t.extends,this.properties=t.properties,this.variables=t.variables,this.uses_with=t.uses_with,this.uses_eval=t.uses_eval,this.parent_scope=t.parent_scope,this.enclosed=t.enclosed,this.cname=t.cname,this.body=t.body,this.block_scope=t.block_scope,this.start=t.start,this.end=t.end),this.flags=0},{$propdoc:{name:"[AST_SymbolClass|AST_SymbolDefClass?] optional class name.",extends:"[AST_Node]? optional parent class",properties:"[AST_ObjectProperty|AST_ClassStaticBlock]* array of properties or static blocks"},$documentation:"An ES6 class",_walk:function(t){return t._visit(this,function(){this.name&&this.name._walk(t),this.extends&&this.extends._walk(t),this.properties.forEach(e=>e._walk(t))})},_children_backwards(t){let e=this.properties.length;for(;e--;)t(this.properties[e]);this.extends&&t(this.extends),this.name&&t(this.name)},visit_nondeferred_class_parts(t){this.extends&&this.extends._walk(t),this.properties.forEach(e=>{e instanceof AST_ClassStaticBlock?e._walk(t):(e.computed_key()&&(t.push(e),e.key._walk(t),t.pop()),(e instanceof AST_ClassPrivateProperty&&e.static&&e.value||e instanceof AST_ClassProperty&&e.static&&e.value)&&(t.push(e),e.value._walk(t),t.pop()))})},visit_deferred_class_parts(t){this.properties.forEach(e=>{e instanceof AST_ConciseMethod||e instanceof AST_PrivateMethod?e.walk(t):(e instanceof AST_ClassProperty&&!e.static&&e.value||e instanceof AST_ClassPrivateProperty&&!e.static&&e.value)&&(t.push(e),e.value._walk(t),t.pop())})},is_self_referential:function(){const t=this.name&&this.name.definition().id;let e=!1,s=!0;return this.visit_nondeferred_class_parts(new TreeWalker((i,n)=>{if(e)return!0;if(i instanceof AST_This)return e=s;if(i instanceof AST_SymbolRef)return e=i.definition().id===t;if(i instanceof AST_Lambda&&!(i instanceof AST_Arrow)){const t=s;return s=!1,n(),s=t,!0}})),e}},AST_Scope),AST_ClassProperty=DEFNODE("ClassProperty","static quote",function(t){t&&(this.static=t.static,this.quote=t.quote,this.key=t.key,this.value=t.value,this.start=t.start,this.end=t.end,this._annotations=t._annotations),this.flags=0},{$documentation:"A class property",$propdoc:{static:"[boolean] whether this is a static key",quote:"[string] which quote is being used"},_walk:function(t){return t._visit(this,function(){this.key instanceof AST_Node&&this.key._walk(t),this.value instanceof AST_Node&&this.value._walk(t)})},_children_backwards(t){this.value instanceof AST_Node&&t(this.value),this.key instanceof AST_Node&&t(this.key)},computed_key(){return!(this.key instanceof AST_SymbolClassProperty)}},AST_ObjectProperty),AST_ClassPrivateProperty=DEFNODE("ClassPrivateProperty","",function(t){t&&(this.static=t.static,this.key=t.key,this.value=t.value,this.start=t.start,this.end=t.end),this.flags=0},{$documentation:"A class property for a private property",_walk:function(t){return t._visit(this,function(){this.value instanceof AST_Node&&this.value._walk(t)})},_children_backwards(t){this.value instanceof AST_Node&&t(this.value)},computed_key:()=>!1},AST_ObjectProperty),AST_PrivateIn=DEFNODE("PrivateIn","key value",function(t){t&&(this.key=t.key,this.value=t.value,this.start=t.start,this.end=t.end),this.flags=0},{$documentation:"An `in` binop when the key is private, eg #x in this",_walk:function(t){return t._visit(this,function(){this.key._walk(t),this.value._walk(t)})},_children_backwards(t){t(this.value),t(this.key)}}),AST_DefClass=DEFNODE("DefClass",null,function(t){t&&(this.name=t.name,this.extends=t.extends,this.properties=t.properties,this.variables=t.variables,this.uses_with=t.uses_with,this.uses_eval=t.uses_eval,this.parent_scope=t.parent_scope,this.enclosed=t.enclosed,this.cname=t.cname,this.body=t.body,this.block_scope=t.block_scope,this.start=t.start,this.end=t.end),this.flags=0},{$documentation:"A class definition"},AST_Class),AST_ClassStaticBlock=DEFNODE("ClassStaticBlock","body block_scope",function(t){this.body=t.body,this.block_scope=t.block_scope,this.start=t.start,this.end=t.end},{$documentation:"A block containing statements to be executed in the context of the class",$propdoc:{body:"[AST_Statement*] an array of statements"},_walk:function(t){return t._visit(this,function(){walk_body(this,t)})},_children_backwards(t){let e=this.body.length;for(;e--;)t(this.body[e])},clone:clone_block_scope,computed_key:()=>!1},AST_Scope),AST_ClassExpression=DEFNODE("ClassExpression",null,function(t){t&&(this.name=t.name,this.extends=t.extends,this.properties=t.properties,this.variables=t.variables,this.uses_with=t.uses_with,this.uses_eval=t.uses_eval,this.parent_scope=t.parent_scope,this.enclosed=t.enclosed,this.cname=t.cname,this.body=t.body,this.block_scope=t.block_scope,this.start=t.start,this.end=t.end),this.flags=0},{$documentation:"A class expression."},AST_Class),AST_Symbol=DEFNODE("Symbol","scope name thedef",function(t){t&&(this.scope=t.scope,this.name=t.name,this.thedef=t.thedef,this.start=t.start,this.end=t.end),this.flags=0},{$propdoc:{name:"[string] name of this symbol",scope:"[AST_Scope/S] the current scope (not necessarily the definition scope)",thedef:"[SymbolDef/S] the definition of this symbol"},$documentation:"Base class for all symbols"}),AST_NewTarget=DEFNODE("NewTarget",null,function(t){t&&(this.start=t.start,this.end=t.end),this.flags=0},{$documentation:"A reference to new.target"}),AST_SymbolDeclaration=DEFNODE("SymbolDeclaration","init",function(t){t&&(this.init=t.init,this.scope=t.scope,this.name=t.name,this.thedef=t.thedef,this.start=t.start,this.end=t.end),this.flags=0},{$documentation:"A declaration symbol (symbol in var/const, function name or argument, symbol in catch)"},AST_Symbol),AST_SymbolVar=DEFNODE("SymbolVar",null,function(t){t&&(this.init=t.init,this.scope=t.scope,this.name=t.name,this.thedef=t.thedef,this.start=t.start,this.end=t.end),this.flags=0},{$documentation:"Symbol defining a variable"},AST_SymbolDeclaration),AST_SymbolBlockDeclaration=DEFNODE("SymbolBlockDeclaration",null,function(t){t&&(this.init=t.init,this.scope=t.scope,this.name=t.name,this.thedef=t.thedef,this.start=t.start,this.end=t.end),this.flags=0},{$documentation:"Base class for block-scoped declaration symbols"},AST_SymbolDeclaration),AST_SymbolConst=DEFNODE("SymbolConst",null,function(t){t&&(this.init=t.init,this.scope=t.scope,this.name=t.name,this.thedef=t.thedef,this.start=t.start,this.end=t.end),this.flags=0},{$documentation:"A constant declaration"},AST_SymbolBlockDeclaration),AST_SymbolUsing=DEFNODE("SymbolUsing",null,function(t){t&&(this.init=t.init,this.scope=t.scope,this.name=t.name,this.thedef=t.thedef,this.start=t.start,this.end=t.end),this.flags=0},{$documentation:"A `using` declaration"},AST_SymbolBlockDeclaration),AST_SymbolLet=DEFNODE("SymbolLet",null,function(t){t&&(this.init=t.init,this.scope=t.scope,this.name=t.name,this.thedef=t.thedef,this.start=t.start,this.end=t.end),this.flags=0},{$documentation:"A block-scoped `let` declaration"},AST_SymbolBlockDeclaration),AST_SymbolFunarg=DEFNODE("SymbolFunarg",null,function(t){t&&(this.init=t.init,this.scope=t.scope,this.name=t.name,this.thedef=t.thedef,this.start=t.start,this.end=t.end),this.flags=0},{$documentation:"Symbol naming a function argument"},AST_SymbolVar),AST_SymbolDefun=DEFNODE("SymbolDefun",null,function(t){t&&(this.init=t.init,this.scope=t.scope,this.name=t.name,this.thedef=t.thedef,this.start=t.start,this.end=t.end),this.flags=0},{$documentation:"Symbol defining a function"},AST_SymbolDeclaration),AST_SymbolMethod=DEFNODE("SymbolMethod",null,function(t){t&&(this.scope=t.scope,this.name=t.name,this.thedef=t.thedef,this.start=t.start,this.end=t.end),this.flags=0},{$documentation:"Symbol in an object defining a method"},AST_Symbol),AST_SymbolClassProperty=DEFNODE("SymbolClassProperty",null,function(t){t&&(this.scope=t.scope,this.name=t.name,this.thedef=t.thedef,this.start=t.start,this.end=t.end),this.flags=0},{$documentation:"Symbol for a class property"},AST_Symbol),AST_SymbolLambda=DEFNODE("SymbolLambda",null,function(t){t&&(this.init=t.init,this.scope=t.scope,this.name=t.name,this.thedef=t.thedef,this.start=t.start,this.end=t.end),this.flags=0},{$documentation:"Symbol naming a function expression"},AST_SymbolDeclaration),AST_SymbolDefClass=DEFNODE("SymbolDefClass",null,function(t){t&&(this.init=t.init,this.scope=t.scope,this.name=t.name,this.thedef=t.thedef,this.start=t.start,this.end=t.end),this.flags=0},{$documentation:"Symbol naming a class's name in a class declaration. Lexically scoped to its containing scope, and accessible within the class."},AST_SymbolBlockDeclaration),AST_SymbolClass=DEFNODE("SymbolClass",null,function(t){t&&(this.init=t.init,this.scope=t.scope,this.name=t.name,this.thedef=t.thedef,this.start=t.start,this.end=t.end),this.flags=0},{$documentation:"Symbol naming a class's name. Lexically scoped to the class."},AST_SymbolDeclaration),AST_SymbolCatch=DEFNODE("SymbolCatch",null,function(t){t&&(this.init=t.init,this.scope=t.scope,this.name=t.name,this.thedef=t.thedef,this.start=t.start,this.end=t.end),this.flags=0},{$documentation:"Symbol naming the exception in catch"},AST_SymbolBlockDeclaration),AST_SymbolImport=DEFNODE("SymbolImport",null,function(t){t&&(this.init=t.init,this.scope=t.scope,this.name=t.name,this.thedef=t.thedef,this.start=t.start,this.end=t.end),this.flags=0},{$documentation:"Symbol referring to an imported name"},AST_SymbolBlockDeclaration),AST_SymbolImportForeign=DEFNODE("SymbolImportForeign","quote",function(t){t&&(this.quote=t.quote,this.scope=t.scope,this.name=t.name,this.thedef=t.thedef,this.start=t.start,this.end=t.end),this.flags=0},{$documentation:"A symbol imported from a module, but it is defined in the other module, and its real name is irrelevant for this module's purposes"},AST_Symbol),AST_Label=DEFNODE("Label","references",function(t){t&&(this.references=t.references,this.scope=t.scope,this.name=t.name,this.thedef=t.thedef,this.start=t.start,this.end=t.end,this.initialize()),this.flags=0},{$documentation:"Symbol naming a label (declaration)",$propdoc:{references:"[AST_LoopControl*] a list of nodes referring to this label"},initialize:function(){this.references=[],this.thedef=this}},AST_Symbol),AST_SymbolRef=DEFNODE("SymbolRef",null,function(t){t&&(this.scope=t.scope,this.name=t.name,this.thedef=t.thedef,this.start=t.start,this.end=t.end),this.flags=0},{$documentation:"Reference to some symbol (not definition/declaration)"},AST_Symbol),AST_SymbolExport=DEFNODE("SymbolExport","quote",function(t){t&&(this.quote=t.quote,this.scope=t.scope,this.name=t.name,this.thedef=t.thedef,this.start=t.start,this.end=t.end),this.flags=0},{$documentation:"Symbol referring to a name to export"},AST_SymbolRef),AST_SymbolExportForeign=DEFNODE("SymbolExportForeign","quote",function(t){t&&(this.quote=t.quote,this.scope=t.scope,this.name=t.name,this.thedef=t.thedef,this.start=t.start,this.end=t.end),this.flags=0},{$documentation:"A symbol exported from this module, but it is used in the other module, and its real name is irrelevant for this module's purposes"},AST_Symbol),AST_LabelRef=DEFNODE("LabelRef",null,function(t){t&&(this.scope=t.scope,this.name=t.name,this.thedef=t.thedef,this.start=t.start,this.end=t.end),this.flags=0},{$documentation:"Reference to a label symbol"},AST_Symbol),AST_SymbolPrivateProperty=DEFNODE("SymbolPrivateProperty",null,function(t){t&&(this.scope=t.scope,this.name=t.name,this.thedef=t.thedef,this.start=t.start,this.end=t.end),this.flags=0},{$documentation:"A symbol that refers to a private property"},AST_Symbol),AST_This=DEFNODE("This",null,function(t){t&&(this.scope=t.scope,this.name=t.name,this.thedef=t.thedef,this.start=t.start,this.end=t.end),this.flags=0},{$documentation:"The `this` symbol"},AST_Symbol),AST_Super=DEFNODE("Super",null,function(t){t&&(this.scope=t.scope,this.name=t.name,this.thedef=t.thedef,this.start=t.start,this.end=t.end),this.flags=0},{$documentation:"The `super` symbol"},AST_This),AST_Constant=DEFNODE("Constant",null,function(t){t&&(this.start=t.start,this.end=t.end),this.flags=0},{$documentation:"Base class for all constants",getValue:function(){return this.value}}),AST_String=DEFNODE("String","value quote",function(t){t&&(this.value=t.value,this.quote=t.quote,this.start=t.start,this.end=t.end,this._annotations=t._annotations),this.flags=0},{$documentation:"A string literal",$propdoc:{value:"[string] the contents of this string",quote:"[string] the original quote character"}},AST_Constant),AST_Number=DEFNODE("Number","value raw",function(t){t&&(this.value=t.value,this.raw=t.raw,this.start=t.start,this.end=t.end),this.flags=0},{$documentation:"A number literal",$propdoc:{value:"[number] the numeric value",raw:"[string] numeric value as string"}},AST_Constant),AST_BigInt=DEFNODE("BigInt","value raw",function(t){t&&(this.value=t.value,this.raw=t.raw,this.start=t.start,this.end=t.end),this.flags=0},{$documentation:"A big int literal",$propdoc:{value:"[string] big int value, represented as a string",raw:"[string] the original format preserved"}},AST_Constant),AST_RegExp=DEFNODE("RegExp","value",function(t){t&&(this.value=t.value,this.start=t.start,this.end=t.end),this.flags=0},{$documentation:"A regexp literal",$propdoc:{value:"[RegExp] the actual regexp"}},AST_Constant),AST_Atom=DEFNODE("Atom",null,function(t){t&&(this.start=t.start,this.end=t.end),this.flags=0},{$documentation:"Base class for atoms"},AST_Constant),AST_Null=DEFNODE("Null",null,function(t){t&&(this.start=t.start,this.end=t.end),this.flags=0},{$documentation:"The `null` atom",value:null},AST_Atom),AST_NaN=DEFNODE("NaN",null,function(t){t&&(this.start=t.start,this.end=t.end),this.flags=0},{$documentation:"The impossible value",value:NaN},AST_Atom),AST_Undefined=DEFNODE("Undefined",null,function(t){t&&(this.start=t.start,this.end=t.end),this.flags=0},{$documentation:"The `undefined` value",value:void 0},AST_Atom),AST_Hole=DEFNODE("Hole",null,function(t){t&&(this.start=t.start,this.end=t.end),this.flags=0},{$documentation:"A hole in an array",value:void 0},AST_Atom),AST_Infinity=DEFNODE("Infinity",null,function(t){t&&(this.start=t.start,this.end=t.end),this.flags=0},{$documentation:"The `Infinity` value",value:1/0},AST_Atom),AST_Boolean=DEFNODE("Boolean",null,function(t){t&&(this.start=t.start,this.end=t.end),this.flags=0},{$documentation:"Base class for booleans"},AST_Atom),AST_False=DEFNODE("False",null,function(t){t&&(this.start=t.start,this.end=t.end),this.flags=0},{$documentation:"The `false` atom",value:!1},AST_Boolean),AST_True=DEFNODE("True",null,function(t){t&&(this.start=t.start,this.end=t.end),this.flags=0},{$documentation:"The `true` atom",value:!0},AST_Boolean);function walk(t,e,s=[t]){const i=s.push.bind(s);for(;s.length;){const t=s.pop(),n=e(t,s);if(n){if(n===walk_abort)return!0}else t._children_backwards(i)}return!1}function walk_parent(t,e,s){const i=[t],n=i.push.bind(i),o=s?s.slice():[],a=[];let r;const l={parent:(t=0)=>-1===t?r:s&&t>=o.length?(t-=o.length,s[s.length-(t+1)]):o[o.length-(1+t)]};for(;i.length;){for(r=i.pop();a.length&&i.length==a[a.length-1];)o.pop(),a.pop();const t=e(r,l);if(t){if(t===walk_abort)return!0;continue}const s=i.length;r._children_backwards(n),i.length>s&&(o.push(r),a.push(s-1))}return!1}const walk_abort=Symbol("abort walk");class TreeWalker{constructor(t){this.visit=t,this.stack=[],this.directives=Object.create(null)}_visit(t,e){this.push(t);var s=this.visit(t,e?function(){e.call(t)}:noop);return!s&&e&&e.call(t),this.pop(),s}parent(t){return this.stack[this.stack.length-2-(t||0)]}push(t){t instanceof AST_Lambda?this.directives=Object.create(this.directives):t instanceof AST_Directive&&!this.directives[t.value]?this.directives[t.value]=t:t instanceof AST_Class&&(this.directives=Object.create(this.directives),this.directives["use strict"]||(this.directives["use strict"]=t)),this.stack.push(t)}pop(){var t=this.stack.pop();(t instanceof AST_Lambda||t instanceof AST_Class)&&(this.directives=Object.getPrototypeOf(this.directives))}self(){return this.stack[this.stack.length-1]}find_parent(t){for(var e=this.stack,s=e.length;--s>=0;){var i=e[s];if(i instanceof t)return i}}is_within_loop(){let t=this.stack.length-1,e=this.stack[t];for(;t--;){const s=this.stack[t];if(s instanceof AST_Lambda)return!1;if(s instanceof AST_IterationStatement&&!(s instanceof AST_For&&e===s.init)&&(!(s instanceof AST_ForIn||s instanceof AST_ForOf)||e!==s.object))return!0;e=s}return!1}find_scope(){for(var t=this.stack,e=t.length;--e>=0;){const s=t[e];if(s instanceof AST_Toplevel)return s;if(s instanceof AST_Lambda)return s;if(s.block_scope)return s.block_scope}}has_directive(t){var e=this.directives[t];if(e)return e;var s=this.stack[this.stack.length-1];if(s instanceof AST_Scope&&s.body)for(var i=0;i<s.body.length;++i){var n=s.body[i];if(!(n instanceof AST_Directive))break;if(n.value==t)return n}}loopcontrol_target(t){var e=this.stack;if(t.label)for(var s=e.length;--s>=0;){if((i=e[s])instanceof AST_LabeledStatement&&i.label.name==t.label.name)return i.body}else for(s=e.length;--s>=0;){var i;if((i=e[s])instanceof AST_IterationStatement||t instanceof AST_Break&&i instanceof AST_Switch)return i}}}class TreeTransformer extends TreeWalker{constructor(t,e){super(),this.before=t,this.after=e}}const _PURE=1,_INLINE=2,_NOINLINE=4,_KEY=8,_MANGLEPROP=16;export{AST_Accessor,AST_Array,AST_Arrow,AST_Assign,AST_Atom,AST_Await,AST_BigInt,AST_Binary,AST_Block,AST_BlockStatement,AST_Boolean,AST_Break,AST_Call,AST_Case,AST_Catch,AST_Chain,AST_Class,AST_ClassExpression,AST_ClassPrivateProperty,AST_PrivateIn,AST_ClassProperty,AST_ClassStaticBlock,AST_ConciseMethod,AST_Conditional,AST_Const,AST_Constant,AST_Continue,AST_Debugger,AST_Default,AST_DefaultAssign,AST_DefClass,AST_Definitions,AST_DefinitionsLike,AST_Defun,AST_Destructuring,AST_Directive,AST_Do,AST_Dot,AST_DotHash,AST_DWLoop,AST_EmptyStatement,AST_Exit,AST_Expansion,AST_Export,AST_False,AST_Finally,AST_For,AST_ForIn,AST_ForOf,AST_Function,AST_Hole,AST_If,AST_Import,AST_ImportMeta,AST_Infinity,AST_IterationStatement,AST_Jump,AST_Label,AST_LabeledStatement,AST_LabelRef,AST_Lambda,AST_Let,AST_LoopControl,AST_NameMapping,AST_NaN,AST_New,AST_NewTarget,AST_Node,AST_Null,AST_Number,AST_Object,AST_ObjectGetter,AST_ObjectKeyVal,AST_ObjectProperty,AST_ObjectSetter,AST_PrefixedTemplateString,AST_PrivateGetter,AST_PrivateMethod,AST_PrivateSetter,AST_PropAccess,AST_RegExp,AST_Return,AST_Scope,AST_Sequence,AST_SimpleStatement,AST_Statement,AST_StatementWithBody,AST_String,AST_Sub,AST_Super,AST_Switch,AST_SwitchBranch,AST_Symbol,AST_SymbolBlockDeclaration,AST_SymbolCatch,AST_SymbolClass,AST_SymbolClassProperty,AST_SymbolConst,AST_SymbolDeclaration,AST_SymbolDefClass,AST_SymbolDefun,AST_SymbolExport,AST_SymbolExportForeign,AST_SymbolFunarg,AST_SymbolImport,AST_SymbolImportForeign,AST_SymbolLambda,AST_SymbolLet,AST_SymbolMethod,AST_SymbolRef,AST_SymbolUsing,AST_SymbolVar,AST_TemplateSegment,AST_TemplateString,AST_SymbolPrivateProperty,AST_This,AST_Throw,AST_Token,AST_Toplevel,AST_True,AST_Try,AST_TryBlock,AST_Unary,AST_UnaryPostfix,AST_UnaryPrefix,AST_Undefined,AST_Using,AST_UsingDef,AST_Var,AST_VarDef,AST_VarDefLike,AST_While,AST_With,AST_Yield,TreeTransformer,TreeWalker,walk,walk_abort,walk_body,walk_parent,_INLINE,_NOINLINE,_PURE,_KEY,_MANGLEPROP};