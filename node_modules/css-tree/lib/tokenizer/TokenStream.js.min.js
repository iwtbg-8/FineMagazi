import{adoptBuffer}from"./adopt-buffer.js";import{cmpStr}from"./utils.js";import tokenNames from"./names.js";import{WhiteSpace,Comment,Delim,EOF,Function as FunctionToken,LeftParenthesis,RightParenthesis,LeftSquareBracket,RightSquareBracket,LeftCurlyBracket,RightCurlyBracket}from"./types.js";const OFFSET_MASK=16777215,TYPE_SHIFT=24,balancePair=new Map([[FunctionToken,RightParenthesis],[LeftParenthesis,RightParenthesis],[LeftSquareBracket,RightSquareBracket],[LeftCurlyBracket,RightCurlyBracket]]);export class TokenStream{constructor(t,e){this.setSource(t,e)}reset(){this.eof=!1,this.tokenIndex=-1,this.tokenType=0,this.tokenStart=this.firstCharOffset,this.tokenEnd=this.firstCharOffset}setSource(t="",e=()=>{}){const s=(t=String(t||"")).length,n=adoptBuffer(this.offsetAndType,t.length+1),o=adoptBuffer(this.balance,t.length+1);let i=0,h=0,r=0,a=-1;for(this.offsetAndType=null,this.balance=null,e(t,(t,e,f)=>{switch(t){default:o[i]=s;break;case h:{let t=16777215&r;for(r=o[t],h=r>>24,o[i]=t,o[t++]=i;t<i;t++)o[t]===s&&(o[t]=i);break}case LeftParenthesis:case FunctionToken:case LeftSquareBracket:case LeftCurlyBracket:o[i]=r,h=balancePair.get(t),r=h<<24|i}n[i++]=t<<24|f,-1===a&&(a=e)}),n[i]=EOF<<24|s,o[i]=s,o[s]=s;0!==r;){const t=16777215&r;r=o[t],o[t]=s}this.source=t,this.firstCharOffset=-1===a?0:a,this.tokenCount=i,this.offsetAndType=n,this.balance=o,this.reset(),this.next()}lookupType(t){return(t+=this.tokenIndex)<this.tokenCount?this.offsetAndType[t]>>24:EOF}lookupOffset(t){return(t+=this.tokenIndex)<this.tokenCount?16777215&this.offsetAndType[t-1]:this.source.length}lookupValue(t,e){return(t+=this.tokenIndex)<this.tokenCount&&cmpStr(this.source,16777215&this.offsetAndType[t-1],16777215&this.offsetAndType[t],e)}getTokenStart(t){return t===this.tokenIndex?this.tokenStart:t>0?t<this.tokenCount?16777215&this.offsetAndType[t-1]:16777215&this.offsetAndType[this.tokenCount]:this.firstCharOffset}substrToCursor(t){return this.source.substring(t,this.tokenStart)}isBalanceEdge(t){return this.balance[this.tokenIndex]<t}isDelim(t,e){return e?this.lookupType(e)===Delim&&this.source.charCodeAt(this.lookupOffset(e))===t:this.tokenType===Delim&&this.source.charCodeAt(this.tokenStart)===t}skip(t){let e=this.tokenIndex+t;e<this.tokenCount?(this.tokenIndex=e,this.tokenStart=16777215&this.offsetAndType[e-1],e=this.offsetAndType[e],this.tokenType=e>>24,this.tokenEnd=16777215&e):(this.tokenIndex=this.tokenCount,this.next())}next(){let t=this.tokenIndex+1;t<this.tokenCount?(this.tokenIndex=t,this.tokenStart=this.tokenEnd,t=this.offsetAndType[t],this.tokenType=t>>24,this.tokenEnd=16777215&t):(this.eof=!0,this.tokenIndex=this.tokenCount,this.tokenType=EOF,this.tokenStart=this.tokenEnd=this.source.length)}skipSC(){for(;this.tokenType===WhiteSpace||this.tokenType===Comment;)this.next()}skipUntilBalanced(t,e){let s,n,o=t;t:for(;o<this.tokenCount&&(s=this.balance[o],!(s<t));o++)switch(n=o>0?16777215&this.offsetAndType[o-1]:this.firstCharOffset,e(this.source.charCodeAt(n))){case 1:break t;case 2:o++;break t;default:this.balance[s]===o&&(o=s)}this.skip(o-this.tokenIndex)}forEachToken(t){for(let e=0,s=this.firstCharOffset;e<this.tokenCount;e++){const n=s,o=this.offsetAndType[e],i=16777215&o;s=i,t(o>>24,n,i,e)}}dump(){const t=new Array(this.tokenCount);return this.forEachToken((e,s,n,o)=>{t[o]={idx:o,type:tokenNames[e],chunk:this.source.substring(s,n),balance:this.balance[o]}}),t}}