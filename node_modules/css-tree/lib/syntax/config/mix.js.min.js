const{hasOwnProperty:hasOwnProperty}=Object.prototype,shape={generic:!0,types:appendOrAssign,atrules:{prelude:appendOrAssignOrNull,descriptors:appendOrAssignOrNull},properties:appendOrAssign,parseContext:assign,scope:deepAssign,atrule:["parse"],pseudo:["parse"],node:["name","structure","parse","generate","walkContext"]};function isObject(e){return e&&e.constructor===Object}function copy(e){return isObject(e)?{...e}:e}function assign(e,n){return Object.assign(e,n)}function deepAssign(e,n){for(const r in n)hasOwnProperty.call(n,r)&&(isObject(e[r])?deepAssign(e[r],n[r]):e[r]=copy(n[r]));return e}function append(e,n){return"string"==typeof n&&/^\s*\|/.test(n)?"string"==typeof e?e+n:n.replace(/^\s*\|\s*/,""):n||null}function appendOrAssign(e,n){if("string"==typeof n)return append(e,n);const r={...e};for(let t in n)hasOwnProperty.call(n,t)&&(r[t]=append(hasOwnProperty.call(e,t)?e[t]:void 0,n[t]));return r}function appendOrAssignOrNull(e,n){const r=appendOrAssign(e,n);return!isObject(r)||Object.keys(r).length?r:null}function mix(e,n,r){for(const t in r)if(!1!==hasOwnProperty.call(r,t))if(!0===r[t])hasOwnProperty.call(n,t)&&(e[t]=copy(n[t]));else if(r[t])if("function"==typeof r[t]){const s=r[t];e[t]=s({},e[t]),e[t]=s(e[t]||{},n[t])}else if(isObject(r[t])){const s={};for(let n in e[t])s[n]=mix({},e[t][n],r[t]);for(let e in n[t])s[e]=mix(s[e]||{},n[t][e],r[t]);e[t]=s}else if(Array.isArray(r[t])){const s={},i=r[t].reduce(function(e,n){return e[n]=!0,e},{});for(const[n,r]of Object.entries(e[t]||{}))s[n]={},r&&mix(s[n],r,i);for(const e in n[t])hasOwnProperty.call(n[t],e)&&(s[e]||(s[e]={}),n[t]&&n[t][e]&&mix(s[e],n[t][e],i));e[t]=s}return e}export default(e,n)=>mix(e,n,shape);