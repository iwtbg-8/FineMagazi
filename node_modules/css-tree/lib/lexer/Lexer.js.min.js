import{SyntaxReferenceError,SyntaxMatchError}from"./error.js";import*as names from"../utils/names.js";import{cssWideKeywords}from"./generic-const.js";import generic from"./generic.js";import{parse,generate,walk}from"../definition-syntax/index.js";import prepareTokens from"./prepare-tokens.js";import{buildMatchGraph}from"./match-graph.js";import{matchAsTree}from"./match.js";import*as trace from"./trace.js";import{matchFragments}from"./search.js";import{getStructureFromConfig}from"./structure.js";const cssWideKeywordsSyntax=buildMatchGraph(cssWideKeywords.join(" | "));function dumpMapSyntax(e,t,r){const s={};for(const n in e)e[n].syntax&&(s[n]=r?e[n].syntax:generate(e[n].syntax,{compact:t}));return s}function dumpAtruleMapSyntax(e,t,r){const s={};for(const[n,a]of Object.entries(e))s[n]={prelude:a.prelude&&(r?a.prelude.syntax:generate(a.prelude.syntax,{compact:t})),descriptors:a.descriptors&&dumpMapSyntax(a.descriptors,t,r)};return s}function valueHasVar(e){for(let t=0;t<e.length;t++)if("var("===e[t].value.toLowerCase())return!0;return!1}function buildMatchResult(e,t,r){return{matched:e,iterations:r,error:t,...trace}}function matchSyntax(e,t,r,s){const n=prepareTokens(r,e.syntax);let a;return valueHasVar(n)?buildMatchResult(null,new Error("Matching for a tree with var() is not supported")):(s&&(a=matchAsTree(n,e.cssWideKeywordsSyntax,e)),s&&a.match||(a=matchAsTree(n,t.match,e),a.match)?buildMatchResult(a.match,null,a.iterations):buildMatchResult(null,new SyntaxMatchError(a.reason,t.syntax,r,a),a.iterations))}export class Lexer{constructor(e,t,r){if(this.cssWideKeywordsSyntax=cssWideKeywordsSyntax,this.syntax=t,this.generic=!1,this.atrules=Object.create(null),this.properties=Object.create(null),this.types=Object.create(null),this.structure=r||getStructureFromConfig(e),e){if(e.types)for(const t in e.types)this.addType_(t,e.types[t]);if(e.generic){this.generic=!0;for(const e in generic)this.addType_(e,generic[e])}if(e.atrules)for(const t in e.atrules)this.addAtrule_(t,e.atrules[t]);if(e.properties)for(const t in e.properties)this.addProperty_(t,e.properties[t])}}checkStructure(e){function t(e,t){s.push({node:e,message:t})}const r=this.structure,s=[];return this.syntax.walk(e,function(e){r.hasOwnProperty(e.type)?r[e.type].check(e,t):t(e,"Unknown node type `"+e.type+"`")}),!!s.length&&s}createDescriptor(e,t,r,s=null){const n={type:t,name:r},a={type:t,name:r,parent:s,serializable:"string"==typeof e||e&&"string"==typeof e.type,syntax:null,match:null};return"function"==typeof e?a.match=buildMatchGraph(e,n):("string"==typeof e?Object.defineProperty(a,"syntax",{get:()=>(Object.defineProperty(a,"syntax",{value:parse(e)}),a.syntax)}):a.syntax=e,Object.defineProperty(a,"match",{get:()=>(Object.defineProperty(a,"match",{value:buildMatchGraph(a.syntax,n)}),a.match)})),a}addAtrule_(e,t){t&&(this.atrules[e]={type:"Atrule",name:e,prelude:t.prelude?this.createDescriptor(t.prelude,"AtrulePrelude",e):null,descriptors:t.descriptors?Object.keys(t.descriptors).reduce((r,s)=>(r[s]=this.createDescriptor(t.descriptors[s],"AtruleDescriptor",s,e),r),Object.create(null)):null})}addProperty_(e,t){t&&(this.properties[e]=this.createDescriptor(t,"Property",e))}addType_(e,t){t&&(this.types[e]=this.createDescriptor(t,"Type",e))}checkAtruleName(e){if(!this.getAtrule(e))return new SyntaxReferenceError("Unknown at-rule","@"+e)}checkAtrulePrelude(e,t){const r=this.checkAtruleName(e);if(r)return r;const s=this.getAtrule(e);return!s.prelude&&t?new SyntaxError("At-rule `@"+e+"` should not contain a prelude"):!s.prelude||t||matchSyntax(this,s.prelude,"",!1).matched?void 0:new SyntaxError("At-rule `@"+e+"` should contain a prelude")}checkAtruleDescriptorName(e,t){const r=this.checkAtruleName(e);if(r)return r;const s=this.getAtrule(e),n=names.keyword(t);return s.descriptors?s.descriptors[n.name]||s.descriptors[n.basename]?void 0:new SyntaxReferenceError("Unknown at-rule descriptor",t):new SyntaxError("At-rule `@"+e+"` has no known descriptors")}checkPropertyName(e){if(!this.getProperty(e))return new SyntaxReferenceError("Unknown property",e)}matchAtrulePrelude(e,t){const r=this.checkAtrulePrelude(e,t);if(r)return buildMatchResult(null,r);const s=this.getAtrule(e);return s.prelude?matchSyntax(this,s.prelude,t||"",!1):buildMatchResult(null,null)}matchAtruleDescriptor(e,t,r){const s=this.checkAtruleDescriptorName(e,t);if(s)return buildMatchResult(null,s);const n=this.getAtrule(e),a=names.keyword(t);return matchSyntax(this,n.descriptors[a.name]||n.descriptors[a.basename],r,!1)}matchDeclaration(e){return"Declaration"!==e.type?buildMatchResult(null,new Error("Not a Declaration node")):this.matchProperty(e.property,e.value)}matchProperty(e,t){if(names.property(e).custom)return buildMatchResult(null,new Error("Lexer matching doesn't applicable for custom properties"));const r=this.checkPropertyName(e);return r?buildMatchResult(null,r):matchSyntax(this,this.getProperty(e),t,!0)}matchType(e,t){const r=this.getType(e);return r?matchSyntax(this,r,t,!1):buildMatchResult(null,new SyntaxReferenceError("Unknown type",e))}match(e,t){return"string"==typeof e||e&&e.type?("string"!=typeof e&&e.match||(e=this.createDescriptor(e,"Type","anonymous")),matchSyntax(this,e,t,!1)):buildMatchResult(null,new SyntaxReferenceError("Bad syntax"))}findValueFragments(e,t,r,s){return matchFragments(this,t,this.matchProperty(e,t),r,s)}findDeclarationValueFragments(e,t,r){return matchFragments(this,e.value,this.matchDeclaration(e),t,r)}findAllFragments(e,t,r){const s=[];return this.syntax.walk(e,{visit:"Declaration",enter:e=>{s.push.apply(s,this.findDeclarationValueFragments(e,t,r))}}),s}getAtrule(e,t=!0){const r=names.keyword(e);return(r.vendor&&t?this.atrules[r.name]||this.atrules[r.basename]:this.atrules[r.name])||null}getAtrulePrelude(e,t=!0){const r=this.getAtrule(e,t);return r&&r.prelude||null}getAtruleDescriptor(e,t){return this.atrules.hasOwnProperty(e)&&this.atrules.declarators&&this.atrules[e].declarators[t]||null}getProperty(e,t=!0){const r=names.property(e);return(r.vendor&&t?this.properties[r.name]||this.properties[r.basename]:this.properties[r.name])||null}getType(e){return hasOwnProperty.call(this.types,e)?this.types[e]:null}validate(){function e(s,n,a,i){if(a.has(n))return a.get(n);a.set(n,!1),null!==i.syntax&&walk(i.syntax,function(i){if("Type"!==i.type&&"Property"!==i.type)return;const o="Type"===i.type?s.types:s.properties,c="Type"===i.type?t:r;hasOwnProperty.call(o,i.name)&&!e(s,i.name,c,o[i.name])||a.set(n,!0)},this)}let t=new Map,r=new Map;for(const r in this.types)e(this,r,t,this.types[r]);for(const t in this.properties)e(this,t,r,this.properties[t]);return t=[...t.keys()].filter(e=>t.get(e)),r=[...r.keys()].filter(e=>r.get(e)),t.length||r.length?{types:t,properties:r}:null}dump(e,t){return{generic:this.generic,types:dumpMapSyntax(this.types,!t,e),properties:dumpMapSyntax(this.properties,!t,e),atrules:dumpAtruleMapSyntax(this.atrules,!t,e)}}toString(){return JSON.stringify(this.dump())}}